Memories are made up of registers. Each register in the memory is one storage location. Storage location is also called as memory location. Memory locations are identified using Address. The total number of bit a memory can store is its capacity.
----------
临界资源: 多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用，一次仅允许一个进程使用的资源称为临界资源。属于临界资源的硬件有打印机、磁带机等，软件有消息缓冲队列、变量、数组、缓冲区等。诸进程间应采取互斥方式，实现对这种资源的共享。
临界区(Critical Section): 每个进程中访问临界资源的那段代码称为临界区。显然，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。
Critical section is a code segment that can be accessed by only one process at a time.

Mutex(互斥锁)是厕所钥匙，一次只能一人拿着这把钥匙去厕所，结束了，这个人把钥匙给队列中的下一个人。
Semaphore(信号量)是一个自由的官方厕所钥匙，我们有四个厕所，他们的锁和钥匙是一样的。信号量开始设置为4，表示4个厕所是自由滴，如果一个人进去了，数量就-1，
如果厕所满了，钥匙数目就为0，信号量数目这时也是0.如果一个人离开厕所，信号量+1，队列中的下一个人可以用啦！
----------
Each thread has
    A program counter
    A register set
    A stack space
----------
多道程序设计: 内存容量越来越大，把多个程序放在内存里并发的执行，不用再从外面一个一个取，减少io消耗，提高了cpu效率。
----------
CPU由运算器、控制器、寄存器、输入设备和输出设备组成，这些器件由处理数据总线相连。

    运算器：进行数据的处理。

    寄存器：进行数据的存储。

    控制器：控制各种器件工作。

    输入设备：将人们熟悉的信息形式转化为机器能识别的信息形式，如键盘、鼠标等。

    输出设备：将计算机运算的结果转化为人们熟悉的信息形式，如显示器、打印机等。

    处理数据总线：连接各种器件，使各个器件进行数据的传送。
----------
socket屏蔽了tcp/ip的通信细节，使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。这就好比操作系统给我们提供了使用底层硬件功能的系统调用，通过系统调用我们可以方便的使用磁盘（文件操作），使用内存，而无需自己去进行磁盘读写，内存管理。socket也是一样的东西，就是提供了tcp/ip协议的抽象，对外提供了一套接口，通过这个接口就可以统一、方便的使用tcp/ip协议的功能了。
----------
操作系统中挂起suspend和阻塞pend的区别如下：
　　一：挂起是一种主动行为，因此恢复也应该要主动完成，而阻塞则是一种被动行为，是在等待事件或资源时任务的表现，你不知道他什么时候被阻塞(pend)，也就不能确切的知道他什么时候恢复阻塞。而且挂起队列在操作系统里可以看成一个，而阻塞队列则是不同的事件或资源（如信号量）就有自己的队列；
　　二：阻塞（pend）就是任务释放CPU，其他任务可以运行，一般在等待某种资源或信号量的时候出现。挂起（suspend）不释放CPU，如果任务优先级高就永远轮不到其他任务运行，一般挂起用于程序调试中的条件中断，当出现某个条件的情况下挂起，然后进行单步调试；
　　三：pend是task主动去等一个事件,或消息.suspend是直接悬挂task,以后这个task和你没任何关系,任何task间的通信或者同步都和这个suspended task没任何关系了,除非你resume task;
　　四：任务调度是操作系统来实现的，任务调度时，直接忽略挂起状态的任务，但是会顾及处于pend下的任务，当pend下的任务等待的资源就绪后，就可以转为ready了。ready只需要等待CPU时间，当然，任务调度也占用开销，但是不大，可以忽略。**可以这样理解，只要是挂起 suspend 状态，操作系统就不在管理这个任务了**；
　　五：挂起是主动的，一般需要用挂起函数进行操作，若没有resume的动作，则此任务一直不会ready。而阻塞是因为资源被其他任务抢占而处于休眠态。两者的表现方式都是从就绪态里“清掉”，即对应标志位清零，只不过实现方式不一样。
----------
进程上下文实际上是进程执行活动全过程的静态描述。我们把已执行过的进程指令和数据在相关寄存器与堆栈中的内容称为**上文**，把正在执行的指令和数据在寄存器和堆栈中的内容称为**正文**，把待执行的指令和数据在寄存器与堆栈中的内容称为**下文**。具体的说，进程上下文包括计算机系统中与执行该进程有关的各种寄存器（例如通用寄存器，程序计数器PC，程序状态字寄存器PS等）的值，程序段在经过编译过后形成的机器指令代码集，数据集及各种堆栈值PCB结构(进程控制块：用于描述进程情况及控制进程运行所需的全部信息，如进程标识符，进程状态，优先级等)。这里，有关寄存器和栈区的内容是重要的，例如没有程序计数器PC和程序状态寄存器PS，CPU将无法知道下一条待执行指令的地址和控制有关操作。
----------
2<<2，也就是把2往左移动2位
把2转换成2进制，就是0000 0010
左移两位就变成0000 1000，也就是10进制的8，2 * 2**2

段地址和偏移地址:
段地址是针对内存的分段而言的，将每一段的段首地址定义为段地址。段地址的存在是由系统的分段存储决定的，通过段地址和偏移地址就能对数据进行寻访。
偏移地址是指段内相对于段起始地址的偏移值，例如一个存储器的大小是1KB,可以把它分为4段，第一段的地址范围就是0—255，第二段的地址范围就是256-511，以此类推。这些段的偏移地址就是在0-255的范围内的。

段寄存器
8086CPU在访问内存时是要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。段地址存放在段寄存器中，8086CPU有4个段寄存器：CS, DS, SS,ES。当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器 CS，DS，SS 来指向这些起始位置。
    CS：代码段寄存器，是 code segment 的缩写；
    DS：数据段寄存器，是 data segment 的缩写；
    SS：堆栈段寄存器，是 stack segment 的缩写；
    ES：附加段寄存器，是 extra segment 的缩写；

CS和IP
CS和IP寄存器，指示了CPU当前要读取指令的地址。CS为段寄存器，IP为指令指针寄存器，纪录要执行的指令在代码段的偏移地址。在8086CPU中，设CS内容为M，IP中内容为N，8086CPU将从 M*16+N 单元开始，读取一条指令并执行。也可以这样描述，任意时刻，CPU将CS:IP指向的内容当做指令执行。计算它们的物理地址只需要把段地址左移4位，也就是乘以16再加上偏移地址就可以了。8086地址线是20位的，寄存器是16位的，所以要左移4位形成20位地址。

段地址: 1F00H, 偏移地址: 1000H,
左移4位就是16进制后面补一个0,
物理地址: 1F000H + 1000H = 20000H
----------
Big-endian
数据的高位字节存放在地址的低端 低位字节存放在地址高端

Little-endian
数据的高位字节存放在地址的高端 低位字节存放在地址低端

字节的高位与低位
举个例子，int a = 0x12345678 ; 那么左边12就是高位字节，右边的78就是低位字节，从左到右，由高到低，注意，高低乃相对而言，比如56相对于78是高字节，相对于34是低字节。

地址的高端与低端
0x00000001
0x00000002
0x00000003
0x00000004
从上倒下，由低到高，地址值小的为低端，地址值大的为高端。
----------
What's the difference between SIGSTOP and SIGTSTP?
    Both signals are designed to suspend (暂停) a process which will be eventually（最后）resumed（恢复）with SIGCONT. The main differences between them are:
    SIGSTOP is a signal sent programmatically (eg: kill -STOP pid ) while SIGTSTP is typically sent by a user typing on a keyboard, usually Control-Z.
    SIGSTOP cannot be ignored. SIGTSTP might be.
----------
操作系统抽象
操作系统为了能够更好地管理计算机系统并对应用程序提供便捷的服务，在操作系统的发展过程中，计算机科学家提出了如下四个个抽象概念，奠定了操作系统内核设计与实现的基础，操作系统原理中的其他基本概念基本上都基于上述这四个操作系统抽象。

中断（Interrupt）
简单地说，中断是处理器在执行过程中的突变，用来响应处理器状态中的特殊变化。比如当应用程序正在执行时，产生了时钟外设中断，导致操作系统打断当前应用程序的执行，转而去处理时钟外设中断，处理完毕后，再回到应用程序被打断的地方继续执行。在操作系统中，有三类中断：外设中断（Device Interrupt）、陷阱中断（Trap Interrupt）和故障中断（Fault Interrupt，也称为exception，异常）。外设中断由外部设备引起的外部I/O事件如时钟中断、控制台中断等。外设中断是异步产生的，与处理器的执行无关。故障中断是在处理器执行指令期间检测到不正常的或非法的内部事件（如除零错、地址访问越界）。陷阱中断是在程序中使用请求操作系统服务的系统调用而引发的有意事件。在后面的叙述中，如果没有特别指出，我们将用简称中断、陷阱、故障来区分这三种特殊的中断事件，在不需要区分的地方，统一用中断表示。

进程（Process）
简单地说，进程是一个正在运行的程序。在计算机系统中，我们可以“同时”运行多个程序，这个“同时”，其实是操作系统给用户造成的一个“幻觉”。大家知道，处理器是计算机系统中的硬件资源。为了提高处理器的利用率，操作系统采用了多道程序技术。如果一个程序因某个事件而不能运行下去时，就把处理器占用权转交给另一个可运行程序。为了刻画多道程序的并发执行的过程，就要引入进程的概念。从操作系统原理上看，一个进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。操作系统中的进程管理需要协调多道程序之间的关系，解决对处理器分配调度策略、分配实施和回收等问题，从而使得处理器资源得到最充分的利用。

虚存（Virtual Memory）
简单地说，虚存就是操作系统通过处理器中的MMU硬件的支持而给应用程序和用户提供一个大的（超过计算机中的内存条容量）、一致的（连续的地址空间）、私有的（其他应用程序无法破坏）的存储空间。这需要操作系统将内存和硬盘结合起来管理，为用户提供一个容量比实际内存大得多的虚拟存储器，并且需要操作系统为应用程序分配内存空间，使用户存放在内存中的程序和数据彼此隔离、互不侵扰。操作系统中的虚存管理与处理器的MMU密切相关。

文件（File）
简单地说，文件就是存放在持久存储介质（比如硬盘、光盘、U盘等）上，方便应用程序和用户读写的数据。当处理器需要访问文件中的数据时，可通过操作系统把它们装入内存。放在硬盘上的程序也是一种文件。文件管理的任务是有效地支持文件的存储、检索和修改等操作。
----------