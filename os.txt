Memories are made up of registers. Each register in the memory is one storage location. Storage location is also called as memory location. Memory locations are identified using Address. The total number of bit a memory can store is its capacity.
----------
所谓临界区（critical regions）就是访问和操作共享数据的代码段。多个内核任务并发访问同一个资源通常是不安全的，编程者必须保证临界区代码被原子地执行。也就是说，代码在执行期间不可被打断，就如同整个临界区是一个不可分割的指令一样。如果两个内核任务处于同一个临界区中，这就是一种错误现象。如果这种情况确实发生了，我们就称它是**竞争状态**。注意竞争状态是小概率事件，因为竞争引起的错误有时出现，有时并不出现，所以调试这种错误会非常困难。**避免并发和防止竞争状态则称为同步**（synchronization）。

临界资源: 多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用，一次仅允许一个进程使用的资源称为临界资源。属于临界资源的硬件有打印机、磁带机等，软件有消息缓冲队列、变量、数组、缓冲区等。诸进程间应采取互斥方式，实现对这种资源的共享。
临界区(Critical Section): 每个进程中访问临界资源的那段代码称为临界区。显然，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。
Critical section is a code segment that can be accessed by only one process at a time.

Mutex(互斥锁)是厕所钥匙，一次只能一人拿着这把钥匙去厕所，结束了，这个人把钥匙给队列中的下一个人。
Semaphore(信号量)是一个自由的官方厕所钥匙，我们有四个厕所，他们的锁和钥匙是一样的。信号量开始设置为4，表示4个厕所是自由滴，如果一个人进去了，数量就-1，
如果厕所满了，钥匙数目就为0，信号量数目这时也是0.如果一个人离开厕所，信号量+1，队列中的下一个人可以用啦！
----------
Each thread has
    A program counter
    A register set
    A stack space
----------
多道程序设计: 内存容量越来越大，把多个程序放在内存里并发的执行，不用再从外面一个一个取，减少io消耗，提高了cpu效率。
----------
CPU由运算器、控制器、寄存器、输入设备和输出设备组成，这些器件由处理数据总线相连。

    运算器：进行数据的处理。

    寄存器：进行数据的存储。

    控制器：控制各种器件工作。

    输入设备：将人们熟悉的信息形式转化为机器能识别的信息形式，如键盘、鼠标等。

    输出设备：将计算机运算的结果转化为人们熟悉的信息形式，如显示器、打印机等。

    处理数据总线：连接各种器件，使各个器件进行数据的传送。
----------
socket屏蔽了tcp/ip的通信细节，使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。这就好比操作系统给我们提供了使用底层硬件功能的系统调用，通过系统调用我们可以方便的使用磁盘（文件操作），使用内存，而无需自己去进行磁盘读写，内存管理。socket也是一样的东西，就是提供了tcp/ip协议的抽象，对外提供了一套接口，通过这个接口就可以统一、方便的使用tcp/ip协议的功能了。
----------
操作系统中挂起suspend和阻塞pend的区别如下：
　　一：挂起是一种主动行为，因此恢复也应该要主动完成，而阻塞则是一种被动行为，是在等待事件或资源时任务的表现，你不知道他什么时候被阻塞(pend)，也就不能确切的知道他什么时候恢复阻塞。而且挂起队列在操作系统里可以看成一个，而阻塞队列则是不同的事件或资源（如信号量）就有自己的队列；
　　二：阻塞（pend）就是任务释放CPU，其他任务可以运行，一般在等待某种资源或信号量的时候出现。挂起（suspend）不释放CPU，如果任务优先级高就永远轮不到其他任务运行，一般挂起用于程序调试中的条件中断，当出现某个条件的情况下挂起，然后进行单步调试；
　　三：pend是task主动去等一个事件,或消息.suspend是直接悬挂task,以后这个task和你没任何关系,任何task间的通信或者同步都和这个suspended task没任何关系了,除非你resume task;
　　四：任务调度是操作系统来实现的，任务调度时，直接忽略挂起状态的任务，但是会顾及处于pend下的任务，当pend下的任务等待的资源就绪后，就可以转为ready了。ready只需要等待CPU时间，当然，任务调度也占用开销，但是不大，可以忽略。**可以这样理解，只要是挂起 suspend 状态，操作系统就不在管理这个任务了**；
　　五：挂起是主动的，一般需要用挂起函数进行操作，若没有resume的动作，则此任务一直不会ready。而阻塞是因为资源被其他任务抢占而处于休眠态。两者的表现方式都是从就绪态里“清掉”，即对应标志位清零，只不过实现方式不一样。
----------
进程上下文实际上是进程执行活动全过程的静态描述。我们把已执行过的进程指令和数据在相关寄存器与堆栈中的内容称为**上文**，把正在执行的指令和数据在寄存器和堆栈中的内容称为**正文**，把待执行的指令和数据在寄存器与堆栈中的内容称为**下文**。具体的说，进程上下文包括计算机系统中与执行该进程有关的各种寄存器（例如通用寄存器，程序计数器PC，程序状态字寄存器PS等）的值，程序段在经过编译过后形成的机器指令代码集，数据集及各种堆栈值PCB结构(进程控制块：用于描述进程情况及控制进程运行所需的全部信息，如进程标识符，进程状态，优先级等)。这里，有关寄存器和栈区的内容是重要的，例如没有程序计数器PC和程序状态寄存器PS，CPU将无法知道下一条待执行指令的地址和控制有关操作。
----------
2<<2，也就是把2往左移动2位
把2转换成2进制，就是0000 0010
左移两位就变成0000 1000，也就是10进制的8，2 * 2**2

段地址和偏移地址:
段地址是针对内存的分段而言的，将每一段的段首地址定义为段地址。段地址的存在是由系统的分段存储决定的，通过段地址和偏移地址就能对数据进行寻访。
偏移地址是指段内相对于段起始地址的偏移值，例如一个存储器的大小是1KB,可以把它分为4段，第一段的地址范围就是0—255，第二段的地址范围就是256-511，以此类推。这些段的偏移地址就是在0-255的范围内的。

段寄存器
8086CPU在访问内存时是要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。段地址存放在段寄存器中，8086CPU有4个段寄存器：CS, DS, SS,ES。当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器 CS，DS，SS 来指向这些起始位置。
    CS：代码段寄存器，是 code segment 的缩写；
    DS：数据段寄存器，是 data segment 的缩写；
    SS：堆栈段寄存器，是 stack segment 的缩写；
    ES：附加段寄存器，是 extra segment 的缩写；

CS和IP
CS和IP寄存器，指示了CPU当前要读取指令的地址。CS为段寄存器，IP为指令指针寄存器，纪录要执行的指令在代码段的偏移地址。在8086CPU中，设CS内容为M，IP中内容为N，8086CPU将从 M*16+N 单元开始，读取一条指令并执行。也可以这样描述，任意时刻，CPU将CS:IP指向的内容当做指令执行。计算它们的物理地址只需要把段地址左移4位，也就是乘以16再加上偏移地址就可以了。8086地址线是20位的，寄存器是16位的，所以要左移4位形成20位地址。

段地址: 1F00H, 偏移地址: 1000H,
左移4位就是16进制后面补一个0,
物理地址: 1F000H + 1000H = 20000H
----------
Big-endian
数据的高位字节存放在地址的低端 低位字节存放在地址高端

Little-endian
数据的高位字节存放在地址的高端 低位字节存放在地址低端

字节的高位与低位
举个例子，int a = 0x12345678 ; 那么左边12就是高位字节，右边的78就是低位字节，从左到右，由高到低，注意，高低乃相对而言，比如56相对于78是高字节，相对于34是低字节。

地址的高端与低端
0x00000001
0x00000002
0x00000003
0x00000004
从上倒下，由低到高，地址值小的为低端，地址值大的为高端。
----------
What's the difference between SIGSTOP and SIGTSTP?
    Both signals are designed to suspend (暂停) a process which will be eventually（最后）resumed（恢复）with SIGCONT. The main differences between them are:
    SIGSTOP is a signal sent programmatically (eg: kill -STOP pid ) while SIGTSTP is typically sent by a user typing on a keyboard, usually Control-Z.
    SIGSTOP cannot be ignored. SIGTSTP might be.
----------
操作系统抽象
操作系统为了能够更好地管理计算机系统并对应用程序提供便捷的服务，在操作系统的发展过程中，计算机科学家提出了如下四个个抽象概念，奠定了操作系统内核设计与实现的基础，操作系统原理中的其他基本概念基本上都基于上述这四个操作系统抽象。

中断（Interrupt）
简单地说，中断是处理器在执行过程中的突变，用来响应处理器状态中的特殊变化。比如当应用程序正在执行时，产生了时钟外设中断，导致操作系统打断当前应用程序的执行，转而去处理时钟外设中断，处理完毕后，再回到应用程序被打断的地方继续执行。在操作系统中，有三类中断：外设中断（Device Interrupt）、陷阱中断（Trap Interrupt）和故障中断（Fault Interrupt，也称为exception，异常）。外设中断由外部设备引起的外部I/O事件如时钟中断、控制台中断等。外设中断是异步产生的，与处理器的执行无关。故障中断是在处理器执行指令期间检测到不正常的或非法的内部事件（如除零错、地址访问越界）。陷阱中断是在程序中使用请求操作系统服务的系统调用而引发的有意事件。在后面的叙述中，如果没有特别指出，我们将用简称中断、陷阱、故障来区分这三种特殊的中断事件，在不需要区分的地方，统一用中断表示。

进程（Process）
简单地说，进程是一个正在运行的程序。在计算机系统中，我们可以“同时”运行多个程序，这个“同时”，其实是操作系统给用户造成的一个“幻觉”。大家知道，处理器是计算机系统中的硬件资源。为了提高处理器的利用率，操作系统采用了多道程序技术。如果一个程序因某个事件而不能运行下去时，就把处理器占用权转交给另一个可运行程序。为了刻画多道程序的并发执行的过程，就要引入进程的概念。从操作系统原理上看，一个进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。操作系统中的进程管理需要协调多道程序之间的关系，解决对处理器分配调度策略、分配实施和回收等问题，从而使得处理器资源得到最充分的利用。

虚存（Virtual Memory）
简单地说，虚存就是操作系统通过处理器中的MMU硬件的支持而给应用程序和用户提供一个大的（超过计算机中的内存条容量）、一致的（连续的地址空间）、私有的（其他应用程序无法破坏）的存储空间。这需要操作系统将内存和硬盘结合起来管理，为用户提供一个容量比实际内存大得多的虚拟存储器，并且需要操作系统为应用程序分配内存空间，使用户存放在内存中的程序和数据彼此隔离、互不侵扰。操作系统中的虚存管理与处理器的MMU密切相关。

文件（File）
简单地说，文件就是存放在持久存储介质（比如硬盘、光盘、U盘等）上，方便应用程序和用户读写的数据。当处理器需要访问文件中的数据时，可通过操作系统把它们装入内存。放在硬盘上的程序也是一种文件。文件管理的任务是有效地支持文件的存储、检索和修改等操作。
----------
栈：存放的是局部变量（在方法和语句块内部定义的变量）：当方法和语句块一结束，空间马上释放
堆：存放的是成员变量（也叫属性，在方法外，在类里，定义的变量）：随着对象而产生，随对象销毁而销毁。
数据段：存放的是类变量（也叫静态变量，和成员变量相比多加上关键字static）：长驻内存，创建好以后，不会消失
代码段：是存放了程序代码的数据：在代码段中，也有可能包含一些只读的常数变量，列如字符串常量等
----------
字符character/char的宽度由字符集规定，比如
ASCII字符集的字符是8bit，
GBK字符集的字符可以是1或2个字节，8或16bit
UNICODE字符集的utf-8字符可以是1,2,3,4,5,6个字节，即8,16,24,32,40,48bit
常见的简体汉字可以是GBK,UTF8编码
GBK每个汉字字符2个字节，16bit
UTF-8每个汉字字符3个字节，24bit
----------
什么是句柄？为什么会有句柄？
从广义上，能够从一个数值拎起一大堆数据的东西都可以叫做句柄。句柄的英文是"Handle"，本义就是"柄"，只是在计算机科学中，被特别地翻译成"句柄"，其实还是个"柄"。从一个小东西拎起一大堆东西，这难道不像是个"柄"吗？
Windows系统中有许多内核对象，比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个"对象"的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：
    暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；
    操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？
所以，Windows操作系统就采用进一步的间接（可以理解为进一步的抽象的过程）：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。 在Windows系统中，这个编号就叫做"句柄"。

Handle本身是一个32位的无符号整数，作为一个索引在一个表中查找对应的内核对象的实际地址。那么这个表在哪里呢？每个进程都有这样的一个表，叫句柄表。该表的第一项就是进程自己的句柄，这也是为什么你调用GetCurrentProcess()总是返回0x7FFFFFFF原因。

简单地说，Handle就是一种用来"间接"代表一个内核对象的整数值。你可以在程序中使用handle来代表你想要操作的内核对象。这里的内核对象包括：事件（Event）、线程、进程、Mutex等等。我们最常见的就是文件句柄（file handle）。
----------
Intelx86系列微机共支持256种向量中断，为使处理器较容易地识别每种中断源，将它们从0到256编号，即赋以一个中断类型码n，Intel把这个8位的无符号整数叫做一个向量，因此，也叫**中断向量**。**所有256种中断可分为两大类：异常和中断**。异常又分为故障（Fault）和陷阱(Trap)，它们的共同特点是既不使用中断控制器，又不能被屏蔽（异常其实是CPU发出的中断信号）。中断又分为外部可屏蔽中断（INTR）和外部非屏蔽中断（NMI），所有I/O设备产生的中断请求（IRQ）均引起屏蔽中断，而紧急的事件（如硬件故障）引起的故障产生非屏蔽中断。
----------
什么数据需要加锁呢？大多数内核数据结构都需要加锁！有一条很好的经验可以帮助我们判断：如果有其它内核任务可以访问这些数据，那么就给这些数据加上某种形式的锁；如果任何其它东西能看到它，那么就要锁住它。
----------
在编写代码的开始阶段就设计恰当的锁是一种基本原则.
----------
分页机制在段机制之后进行，以完成线性——物理地址的转换过程。段机制把虚拟地址转换为线性地址，分页机制进一步把该线性地址再转换为物理地址。
----------
同步机制的要求
主要
    1. 相互排斥
        我们的解决方案必须提供相互排斥。通过相互排斥，如果一个进程在临界区内执行，那么另一个进程不能进入临界区。
    2. 进程
        进程意味着如果一个进程不需要执行到临界区，那么它不应该阻止其他进程进入临界区。
次要
    1. 有界等待
        我们应该能够预测每个流程进入临界区的等待时间。 这个进程不能无休止地等待进入临界区。
    2. 架构中立
        我们的机制必须是架构中立的。 这意味着如果解决方案在一个架构上运行良好，那么它也应该在其他架构上运行。
----------
As a program runs, the memory addresses that it uses to reference its data is the logical address. The real time translation to the physical address is performed in hardware by the **CPU’s Memory Management Unit** (MMU). The MMU has two special registers that are accessed by the CPU’s control unit. A data to be sent to main memory or retrieved from memory is stored in the Memory Data Register (**MDR**). The desired logical memory address is stored in the Memory Address Register (**MAR**). The address translation is also called address binding and uses a memory map that is programmed by the operating system.
----------
The **Virtual Memory Management system** maintains **a copy of the memory for per program** on secondary storage, such as a hard drive. With a virtual memory management system, the logical address space becomes a virtual address space that uses the full range of memory addresses for each process (0 to 4 GB for a 32 bit system).
----------
十进制小数→→→→→二进制小数 方法：“乘2取整”

对十进制小数乘2得到的整数部分和小数部分,整数部分既是相应的二进制数码,再用2乘小数部分(之前乘后得到新的小数部分),又得到整数和小数部分.
如此不断重复,直到小数部分为0或达到精度要求为止.第一次所得到为最高位,最后一次得到为最低位

0.8125的二进制

0.8125*2=1.625   取整是1

0.625*2=1.25     取整是1

0.25*2=0.5       取整是0

0.5*2=1.0        取整是1

即0.8125的二进制是0.1101（第一次所得到为最高位,最后一次得到为最低位）
----------
Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。 简单说，官方推荐使用StrictRedis方法。
----------
在UNIX 系统中，一个进程结束了，但是他的父进程没有等待(调用wait/waitpid)他，那么他将变成一个僵尸进程。但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程，因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程，看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由Init来接管他，成为他的父进程。
在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）。直到父进程通过wait/waitpid来取时才释放。如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。
僵尸进程的避免
⒈父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。
⒉ 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后，父进程会收到该信号，可以在handler中调用wait回收。
⒊ 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN）通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号。
⒋ 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。
----------