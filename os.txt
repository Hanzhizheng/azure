Memories are made up of registers. Each register in the memory is one storage location. Storage location is also called as memory location. Memory locations are identified using Address. The total number of bit a memory can store is its capacity.
----------
临界资源: 多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用，一次仅允许一个进程使用的资源称为临界资源。属于临界资源的硬件有打印机、磁带机等，软件有消息缓冲队列、变量、数组、缓冲区等。诸进程间应采取互斥方式，实现对这种资源的共享。
临界区(Critical Section): 每个进程中访问临界资源的那段代码称为临界区。显然，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。
Critical section is a code segment that can be accessed by only one process at a time.

Mutex(互斥锁)是厕所钥匙，一次只能一人拿着这把钥匙去厕所，结束了，这个人把钥匙给队列中的下一个人。
Semaphore(信号量)是一个自由的官方厕所钥匙，我们有四个厕所，他们的锁和钥匙是一样的。信号量开始设置为4，表示4个厕所是自由滴，如果一个人进去了，数量就-1，
如果厕所满了，钥匙数目就为0，信号量数目这时也是0.如果一个人离开厕所，信号量+1，队列中的下一个人可以用啦！
----------
Each thread has
    A program counter
    A register set
    A stack space
----------
多道程序设计: 内存容量越来越大，把多个程序放在内存里并发的执行，不用再从外面一个一个取，减少io消耗，提高了cpu效率。
----------
CPU由运算器、控制器、寄存器、输入设备和输出设备组成，这些器件由处理数据总线相连。

    运算器：进行数据的处理。

    寄存器：进行数据的存储。

    控制器：控制各种器件工作。

    输入设备：将人们熟悉的信息形式转化为机器能识别的信息形式，如键盘、鼠标等。

    输出设备：将计算机运算的结果转化为人们熟悉的信息形式，如显示器、打印机等。

    处理数据总线：连接各种器件，使各个器件进行数据的传送。
----------
socket屏蔽了tcp/ip的通信细节，使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。这就好比操作系统给我们提供了使用底层硬件功能的系统调用，通过系统调用我们可以方便的使用磁盘（文件操作），使用内存，而无需自己去进行磁盘读写，内存管理。socket也是一样的东西，就是提供了tcp/ip协议的抽象，对外提供了一套接口，通过这个接口就可以统一、方便的使用tcp/ip协议的功能了。
----------
操作系统中挂起suspend和阻塞pend的区别如下：
　　一：挂起是一种主动行为，因此恢复也应该要主动完成，而阻塞则是一种被动行为，是在等待事件或资源时任务的表现，你不知道他什么时候被阻塞(pend)，也就不能确切的知道他什么时候恢复阻塞。而且挂起队列在操作系统里可以看成一个，而阻塞队列则是不同的事件或资源（如信号量）就有自己的队列；
　　二：阻塞（pend）就是任务释放CPU，其他任务可以运行，一般在等待某种资源或信号量的时候出现。挂起（suspend）不释放CPU，如果任务优先级高就永远轮不到其他任务运行，一般挂起用于程序调试中的条件中断，当出现某个条件的情况下挂起，然后进行单步调试；
　　三：pend是task主动去等一个事件,或消息.suspend是直接悬挂task,以后这个task和你没任何关系,任何task间的通信或者同步都和这个suspended task没任何关系了,除非你resume task;
　　四：任务调度是操作系统来实现的，任务调度时，直接忽略挂起状态的任务，但是会顾及处于pend下的任务，当pend下的任务等待的资源就绪后，就可以转为ready了。ready只需要等待CPU时间，当然，任务调度也占用开销，但是不大，可以忽略。**可以这样理解，只要是挂起 suspend 状态，操作系统就不在管理这个任务了**；
　　五：挂起是主动的，一般需要用挂起函数进行操作，若没有resume的动作，则此任务一直不会ready。而阻塞是因为资源被其他任务抢占而处于休眠态。两者的表现方式都是从就绪态里“清掉”，即对应标志位清零，只不过实现方式不一样。
----------
进程上下文实际上是进程执行活动全过程的静态描述。我们把已执行过的进程指令和数据在相关寄存器与堆栈中的内容称为**上文**，把正在执行的指令和数据在寄存器和堆栈中的内容称为**正文**，把待执行的指令和数据在寄存器与堆栈中的内容称为**下文**。具体的说，进程上下文包括计算机系统中与执行该进程有关的各种寄存器（例如通用寄存器，程序计数器PC，程序状态字寄存器PS等）的值，程序段在经过编译过后形成的机器指令代码集，数据集及各种堆栈值PCB结构(进程控制块：用于描述进程情况及控制进程运行所需的全部信息，如进程标识符，进程状态，优先级等)。这里，有关寄存器和栈区的内容是重要的，例如没有程序计数器PC和程序状态寄存器PS，CPU将无法知道下一条待执行指令的地址和控制有关操作。
----------