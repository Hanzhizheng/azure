安装
    pip install fastapi[all]
运行
    uvicorn main:app --reload
文档
    http://127.0.0.1:8000/docs
----------
路径参数
    使用
        @app.get("/items/{item_id}")  # 路径参数同格式化字符串语法
        async def read_item(item_id: int):  # 路径参数类型声明int
            return {"item_id": item_id}
    注意
        路径顺序很重要
            如/user/me 和 /user/{user_id}，me需要在user_id前面，否则，user_id的路径还将与me相匹配，"认为"自己正在接收一个值为"me"的user_id参数。
    枚举值
        导入 Enum 并创建一个继承自 str 和 Enum 的子类。
        通过从 str 继承，API 文档将能够知道这些值必须为 string 类型并且能够正确地展示出来（文档中路径值变为下拉框）
        然后创建具有固定值的类属性，这些固定值将是可用的有效值
        
        from enum import Enum
        from fastapi import FastAPI
        
        class ModelName(str, Enum):
            alexnet = "alexnet"
            lenet = "lenet"

        @app.get("/models/{model_name}")
        async def get_model(model_name: ModelName):
            if model_name == ModelName.alexnet:
                return {"model_name": model_name, "message": "Deep"}
            if model_name.value == "lenet":  # .value 是Enum子类方法
                return {"model_name": model_name, "message": "LeCNN"}
            return {"model_name": model_name, "message": "Have some residuals"}
    包含路径的路径参数
        假设你有一个路径操作，它的路径为 /files/{file_path}
        但是你需要 file_path 自身也包含路径，比如 home/johndoe/myfile.txt
        因此，该文件的URL将类似于这样：/files/home/johndoe/myfile.txt
        你可以使用直接来自 Starlette 的选项来声明一个包含路径的路径参数：
        /files/{file_path:path}
        参数的名称为 file_path，结尾部分的 :path 说明该参数应匹配任意的路径。
----------
查询参数
    路径参数中不包含的函数参数，将被自动解释为"查询字符串"参数
    默认值
        @app.get("/items/")
        async def read_item(skip: int = 0, limit: int = 10):
            因此，访问 URL：
                http://127.0.0.1:8000/items/
            将与访问以下地址相同：
                http://127.0.0.1:8000/items/?skip=0&limit=10
    可选参数
        @app.get("/items/{item_id}")
        async def read_item(item_id: str, q: Optional[str] = None):
    查询参数类型转换
        声明 bool 类型，它们将被自动转换
    必须查询参数
        当你想让一个查询参数成为必需的，不声明任何默认值就可以q: str
----------
请求体
使用 Pydantic 模型来声明请求体，并能够获得它们所具有的所有能力和优点。

    导入 Pydantic 的 BaseModel
    创建数据模型
        和声明查询参数时一样，当一个属性具有默认值时，它不是必需的。否则它是一个必需属性。将默认值设为 None 可使其成为可选属性。
        class Item(BaseModel):
            name: str
            description: Optional[str] = None
            price: float
            tax: Optional[float] = None
    声明参数&使用模型
    Pydantic 模型具有 .dict（） 方法，该方法返回一个拥有模型数据的 dict。
        @app.post("/items/")
        async def create_item(item: Item):  # 声明参数
            item_dict = item.dict()  # 使用模型
    流程
        将请求体作为 JSON 读取。
        转换为相应的类型（在需要时）。
        校验数据，数据无效，返回错误
        将接收的数据赋值到参数 item 中。   
----------
函数参数将依次按如下规则进行识别：
    如果在路径中也声明了该参数，它将被用作路径参数。
    如果参数属于单一类型（比如 int、float、str、bool 等）它将被解释为查询参数。
    如果参数的类型被声明为一个 Pydantic 模型，它将被解释为请求体。
----------
Query
    显示声明查询参数：Query 第一个参数为默认值，为None表示该参数可选，为...表示必需
        from fastapi import Query
        @app.get("/items/")
        async def read_items(
            q: Optional[str] = Query(None, min_length=3, max_length=50, regex="^fixedquery$")
        ):
    查询参数可以为列表
        http://localhost:8000/items/?q=foo&q=bar
        @app.get("/items/")
        async def read_items(q: List[str] = Query(["foo", "bar"])):  # 可带默认值，可选None

Path
    from fastapi import Path
    路径参数总是必需的，因为它必须是路径的一部分。
    所以，你应该在声明时使用 ... 将其标记为必需参数，None和默认值无效

    与使用 Query 为查询参数声明更多的校验和元数据的方式相同，可以使用 Path 为路径参数声明相同类型的校验和元数据。
    
Body
    默认单一值识别为查询参数，如果需要请求体为单一值而不定义pydantic，可以使用Body：from fastapi import Body
    
    Body 同样具有与 Query、Path 以及其他后面将看到的类完全相同的额外校验和元数据参数。
    
    你可以添加多个请求体参数到路径操作函数中，即使一个请求只能有一个请求体。
    但是 FastAPI 会处理它，在函数中为你提供正确的数据，并在路径操作中校验并记录正确的模式。

    你还可以指示 FastAPI 在仅声明了一个请求体参数的情况下，将原本的请求体嵌入到一个键中。
        async def update_item(item_id: int, item: Item = Body(..., embed=True)):
            results = {"item_id": item_id, "item": item}
            return results
        在这种情况下，FastAPI 将期望像这样的请求体：
            {
                "item": {
                    "name": "Foo",
                    "description": "The pretender",
                    "price": 42.0,
                    "tax": 3.2
                }
            }
        而不是：
            {
                "name": "Foo",
                "description": "The pretender",
                "price": 42.0,
                "tax": 3.2
            }
            
Pydantic Field
    与使用 Query、Path 和 Body 在路径操作函数中声明额外的校验和元数据的方式相同，你可以使用 Pydantic 的 Field 在 Pydantic 模型内部声明校验和元数据。

Query 和 Path 和 Body 和 Field 参数
        通用的校验和元数据：
            alias  # 别名
            title
            description  # 参数描述
            deprecated  # 暂时弃用
        特定于字符串的校验：
            min_length
            max_length
            regex
        数值校验
            gt：大于（greater than）
            ge：大于等于（greater than or equal）
            lt：小于（less than）
            le：小于等于（less than or equal）

你可以像定义 Query 参数和 Path 参数一样来定义 Cookie, Header参数。
    Header
        默认情况下, Header 将把参数名称的字符从下划线 (_) 转换为连字符 (-) 来提取并记录 headers.
        HTTP headers 是大小写不敏感的
        你可以通过一个Python list 的形式获得重复header的所有值。
            @app.get("/items/")
            async def read_items(x_token: Optional[List[str]] = Header(None)):
                return {"X-Token values": x_token}

            如果你与路径操作通信时发送两个HTTP headers，就像：

            X-Token: foo
            X-Token: bar

            响应会是:

            {
                "X-Token values": [
                    "bar",
                    "foo"
                ]
            }
----------
额外信息
    您可以使用 Config 和 schema_extra 为Pydantic模型声明一个示例
        class Item(BaseModel):
            name: str
            description: Optional[str] = None
            price: float
            tax: Optional[float] = None

            class Config:
                schema_extra = {
                    "example": {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    }
                }
    你可以通过传递额外信息给 Field 同样的方式操作Path, Query, Body等。
        class Item(BaseModel):
            name: str = Field(..., example="Foo")
        
        @app.put("/items/{item_id}")
        async def update_item(
            item_id: int,
            item: Item = Body(
                ...,
                example={
                    "name": "Foo",
                    "description": "A very nice Item",
                    "price": 35.4,
                    "tax": 3.2,
                },
            ),
        ):
----------
额外数据类型
    你可以使用复杂的数据类型声明，如UUID，datetime.datetime，datetime.timedelta, bytes, frozenset
----------
响应体
    你可以在任意的路径操作装饰器中使用 response_model 参数来声明用于响应的模型
    类型
        Pydantic 模型，但也可以是一个由 Pydantic 模型组成的 list，例如 List[Item]。
            class Item(BaseModel):
                name: str
                description: Optional[str] = None
                price: float
                tax: Optional[float] = None
                tags: List[str] = []

            @app.post("/items/", response_model=Item)
        Union组合，意味着该响应将是两种类型中的任何一种
            定义一个 Union 类型时，首先包括最详细的类型，然后是不太详细的类型
            class CarItem(BaseItem):
                type = "car"
                
            class PlaneItem(BaseItem):
                type = "plane"
                size: int
            @app.get("/items/{item_id}", response_model=Union[PlaneItem, CarItem])
        
        Dict，如果你事先不知道有效的字段/属性名称（对于 Pydantic 模型是必需的），这将很有用。
            @app.get("/keyword-weights/", response_model=Dict[str, float])

    装饰器中响应体相关参数
        response_model_exclude_defaults=True 
        response_model_exclude_none=True 
        response_model_exclude_unset=True  // 使用 response_model_exclude_unset 来仅返回显式设定的值
        response_model_include 和 response_model_exclude
            它们接收一个由属性名称 str 组成的 set 或 list 或 tuple 来包含（忽略其他的）或者排除（包含其他的）这些属性。
----------
响应码
    @app.post("/items/", status_code=201)
    @app.post("/items/", status_code=status.HTTP_201_CREATED)
----------
表单数据和json数据
form表单是“键值对”的数据格式，例如：
    a=1&b=2&c=3
而json格式则与之不同，如下：
    {"a":1,"b":2,"c":3}
传递的数据比较简单，那么两种方式基本上没什么大区别（当然后台接收数据的方式肯定是不同的），
如果数据比较复杂，比如包含数组、对象等时，就只有json才能胜任了。
此外，如果数据是通过表单提交的，那么当然使用默认的form即可，因为它会自动构建数据结构，无需手工拼接；
而如果是通过ajax发送数据，则最好使用json，因为可以通过简单的方法把对象转换为json字串。
----------
表单Form（Body子类）
    安装
        pip install python-multipart.
    使用
        from fastapi import FastAPI, Form

        app = FastAPI()

        @app.post("/login/")
        async def login(username: str = Form(...), password: str = Form(...)):
            return {"username": username}
    与使用 Query、Path 和 Body 在路径操作函数中声明额外的校验和元数据的方式相同
----------
Data from forms is normally encoded using the "media type" application/x-www-form-urlencoded.
But when the form includes files, it is encoded as multipart/form-data.
----------
文件File（Form子类）
    安装
        pip install python-multipart.
    使用
        from fastapi import FastAPI, File, UploadFile
        app = FastAPI()

        @app.post("/files/")
        async def create_file(file: bytes = File(...)):
            # 类型为bytes，Fastapi会自动读取文件内容
            # 注意内容会全部存在内存中
            return {"file_size": len(file)}
        
        @app.post("/uploadfile/")
        async def create_upload_file(file: UploadFile = File(...)):
            # UploadFile可以存储大文件
            # 可以获得文件元数据
            return {"filename": file.filename}
    UploadFile
        属性
            filename
            content_type
            file：a SpooledTemporaryFile (a file-like object).
                  This is the actual Python file that you can pass directly to other functions or libraries that expect a "file-like" object
        异步方法(必需await，e.g. contents = await myfile.read()，在非同步函数中，contents = myfile.file.read())
            write(data)
            read(size)
            seek(offset)
            close()
    多个文件
        @app.post("/files/")
        async def create_files(files: List[bytes] = File(...)):
            return {"file_sizes": [len(file) for file in files]}

        @app.post("/uploadfiles/")
        async def create_upload_files(files: List[UploadFile] = File(...)):
            return {"filenames": [file.filename for file in files]}
----------
处理错误
    raise HTTPException(
        status_code=404,
        detail="Item not found",
        headers={"X-Error": "There goes my error"},  # 自定义header
    )
    客户端结果
        {
          "detail": "Item not found"
        }
    自定义异常处理器
        from fastapi import FastAPI, Request
        from fastapi.responses import PlainTextResponse

        class CustomException(Exception):  # 其他异常也可以
            def __init__(self, name: str):
                self.name = name

        app = FastAPI()

        @app.exception_handler(CustomException)
        async def unicorn_exception_handler(request: Request, exc: CustomException):
            return PlainTextResponse(
                exc.name,
                status_code=418,
            )

        @app.get("/unicorns/{name}")
        async def read_unicorn(name: str):
            raise CustomException(name=name)
            return {"unicorn_name": name}
        
    Use the RequestValidationError body
        The RequestValidationError contains the body it received with invalid data.
        You could use it while developing your app to log the body and debug it, return it to the user, etc.

        from fastapi import FastAPI, Request, status
        from fastapi.encoders import jsonable_encoder
        from fastapi.exceptions import RequestValidationError
        from fastapi.responses import JSONResponse
        from pydantic import BaseModel

        app = FastAPI()

        @app.exception_handler(RequestValidationError)
        async def validation_exception_handler(request: Request, exc: RequestValidationError):
            return JSONResponse(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                content=jsonable_encoder({"detail": exc.errors(), "body": exc.body}),
            )

    FastAPI HTTPException 继承自 Starlette's HTTPException。
        FastAPI HTTPException允许你在response添加头信息，主要用于OAuth 2.0以及一些安全相关的功能。
        因此，通常我们在代码中抛出FastAPI HTTPException异常。
        但是，当我们注册异常处理器的时候，我们应该注册为Starlette HTTPException。
        尽管注册的是Starlette HTTPException处理器，抛出HTTPException异常依然捕获得到。
        如果我们要在代码中同时使用这两个类，为了避免命名冲突，我们可以重命名其中一个类。
        from fastapi import HTTPException
        from starlette.exceptions import HTTPException as StarletteHTTPException

    使用默认handler
        from fastapi.exception_handlers import (
            http_exception_handler,
        )
        from starlette.exceptions import HTTPException as StarletteHTTPException

        @app.exception_handler(StarletteHTTPException)
        async def custom_http_exception_handler(request, exc):
            print(f"OMG! An HTTP error!: {repr(exc)}")
            print(type(exc))  # <class 'fastapi.exceptions.HTTPException'>
            return await http_exception_handler(request, exc)
        @app.get("/items/{item_id}")
        async def read_item(item_id: int):
            if item_id == 3:
                raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
            return {"item_id": item_id}
        In this example, you are just printing the error with a very expressive message.
        But you get the idea, you can use the exception and then just re-use the default exception handlers.
----------
路径配置
    tags
        @app.get("/items/", tags="items")
    summary and description
        @app.post(
            "/items/",
            response_model=Item,
            summary="Create an item",
            description="Create an item with all the information, name, description, price, tax and a set of unique tags",
        )
    Markdown描述模型
        @app.post("/items/", response_model=Item, summary="Create an item")
        async def create_item(item: Item):
            """
            Create an item with all the information:

            - **name**: each item must have a name
            - **description**: a long description
            - **price**: required
            - **tax**: if the item doesn't have tax, you can omit this
            - **tags**: a set of unique tag strings for this item
            """
            return item
    response_description
        @app.post(
            "/items/",
            response_model=Item,
            summary="Create an item",
            response_description="The created item",
        )
    弃用某个路径（弃用路径在文档中变成灰色）
        @app.get("/elements/", tags=["items"], deprecated=True)
    从文档中隐藏
        @app.get("/items/", include_in_schema=False)
----------
jsonable_encoder
    convert a data type (like a Pydantic model) to something compatible with JSON (like a dict, list, etc).
    The result of calling it is something that can be encoded with the Python standard json.dumps().
----------
替换更新PUT
部分更新PATCH
    @app.patch("/items/{item_id}", response_model=Item)
    async def update_item(item_id: str, item: Item):
        stored_item_data = items[item_id]  # get data from database
        stored_item_model = Item(**stored_item_data)
        update_data = item.dict(exclude_unset=True)
        updated_item = stored_item_model.copy(update=update_data)
        items[item_id] = jsonable_encoder(updated_item)  # save to database
        return updated_item

    In summary, to apply partial updates you would:
        (Optionally) use PATCH instead of PUT.
        Retrieve the stored data.
        Put that data in a Pydantic model.
        Generate a dict without default values from the input model (using exclude_unset).
            This way you can update only the values actually set by the user, instead of overriding values already stored with default values in your model.
        Create a copy of the stored model, updating it's attributes with the received partial updates (using the update parameter).
        Convert the copied model to something that can be stored in your DB (for example, using the jsonable_encoder).
        Save the data to your DB.
        Return the updated model.
        
    You can actually use this same technique with an HTTP PUT operation.
----------
依赖注入
    用处
        重复使用代码
        共享数据库链接
        安全，认证等
    使用
        # 函数
            async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):
                return {"q": q, "skip": skip, "limit": limit}
            @app.get("/items/")
            async def read_items(commons: dict = Depends(common_parameters)):
                return commons

            @app.get("/users/")
            async def read_users(commons: dict = Depends(common_parameters)):
                return commons
        # 类
            class CommonQueryParams:
                def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100):
                    self.q = q
                    self.skip = skip
                    self.limit = limit

            @app.get("/items/")
            async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
            #简写
            async def read_items(commons: CommonQueryParams = Depends()):
        # 装饰器里使用依赖注入
        # 装饰器里依赖不会用到返回值，适合执行流程类函数
            async def verify_token(x_token: str = Header(...)):
                if x_token != "fake-super-secret-token":
                    raise HTTPException(status_code=400, detail="X-Token header invalid")

            async def verify_key(x_key: str = Header(...)):
                if x_key != "fake-super-secret-key":
                    raise HTTPException(status_code=400, detail="X-Key header invalid")
                return x_key

            @app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
            
    全局依赖
        app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])

    依赖 with yield
        async def get_db():
            db = DBSession()
            try:
                yield db  # 响应前部分
            finally:
                db.close()  # 响应后部分

    依赖 上下文管理器            
        class MySuperContextManager:
            def __init__(self):
                self.db = DBSession()

            def __enter__(self):
                return self.db

            def __exit__(self, exc_type, exc_value, traceback):
                self.db.close()
                
        async def get_db():
            with MySuperContextManager() as db:
                yield db

    use_cache 是否使用缓存结果
        async def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):
            return {"fresh_value": fresh_value}
----------
安全
    生成token
        @app.post("/token")  # 响应必须是一个 JSON 对象。
        async def login(form_data: OAuth2PasswordRequestForm = Depends()):
            # OAuth2PasswordRequestForm一个包含username和password的表单
            return {"access_token": user.username, "token_type": "bearer"}
            # 包含access_token和token_type的JSON对象，固定值，必须有
    
    前端发送带有token的header

    依赖注入 OAuth2PasswordBearer，从header中提取token
        oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
        # OAuth2PasswordBearer use OAuth2, with the Password flow, using a Bearer token
        # tokenUrl对应获得token的路径
            async def read_items(token: str = Depends(oauth2_scheme)):
                
    jwt令牌
        pip install python-jose[cryptography]生成和校验 JWT 令牌
        SECRET_KEY = openssl rand -hex 32 生成随机密钥
        ALGORITHM = "HS256" 设置算法
        ACCESS_TOKEN_EXPIRE_MINUTES = 30 设置过期时间
        
        def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
            to_encode = data.copy()
            if expires_delta:
                expire = datetime.utcnow() + expires_delta
            else:
                expire = datetime.utcnow() + timedelta(minutes=15)
            to_encode.update({"exp": expire})
            encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
            return encoded_jwt
                @app.post("/token", response_model=Token)

        async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
            user = authenticate_user(fake_users_db, form_data.username, form_data.password)
            if not user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Incorrect username or password",
                    headers={"WWW-Authenticate": "Bearer"},
                )
            access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
            access_token = create_access_token(
                data={"sub": user.username}, expires_delta=access_token_expires
            )
            # JWT 的规范中提到有一个 sub 键，值为该令牌的主题。
            # 为了避免 ID 冲突，当为用户创建 JWT 令牌时，你可以在 sub 键的值前加上前缀，例如 username:
            # sub 键在整个应用程序中应该有一个唯一的标识符，而且应该是一个字符串
            return {"access_token": access_token, "token_type": "bearer"}
            
        async def get_current_user(token: str = Depends(oauth2_scheme)):
            credentials_exception = HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )
            try:
                payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
                username: str = payload.get("sub")
                if username is None:
                    raise credentials_exception
                token_data = TokenData(username=username)
            except JWTError:
                raise credentials_exception
            user = get_user(fake_users_db, username=token_data.username)
            if user is None:
                raise credentials_exception
            return user

        @app.get("/users/me/", response_model=User)
        async def read_users_me(current_user: User = Depends(get_current_user)):
            return current_user

        使用 scopes 的进阶用法
            OAuth2 具有「作用域」的概念。
            你可以使用它们向 JWT 令牌添加一组特定的权限。
            然后，你可以将此令牌直接提供给用户或第三方，使其在一些限制下与你的 API 进行交互。

    哈希并校验密码
        pip install passlib[bcrypt]
        from passlib.context import CryptContext

        pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        
        def get_password_hash(password):
            return pwd_context.hash(password)
        def verify_password(plain_password, hashed_password):
            return pwd_context.verify(plain_password, hashed_password)
----------
中间件
    "中间件"是一个函数,它在每个请求被特定的路径操作处理之前,以及在每个响应返回之前工作.
    在函数的顶部使用装饰器 @app.middleware("http").
    The middleware has to be an async function.
    中间件参数接收如下参数:
        request
        call_next：它将接收 request 作为参数.
        这个函数将 request 传递给相应的 路径操作.
        然后它将返回由相应的路径操作生成的 response.
        然后你可以在返回 response 前进一步修改它.

    import time
    from fastapi import FastAPI, Request

    app = FastAPI()

    @app.middleware("http")
    async def add_process_time_header(request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        response.headers["X-Process-Time"] = str(process_time)  # 请记住可以 用'X-' 前缀添加专有自定义请求头.
        return response

    一些中间件
        HTTPSRedirectMiddleware
            Enforces that all incoming requests must either be https or wss.        
            Any incoming requests to http or ws will be redirected to the secure scheme instead.
        TrustedHostMiddleware
            Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks.
        GZipMiddleware
            Handles GZip responses for any request that includes "gzip" in the Accept-Encoding header.
            The middleware will handle both standard and streaming responses.
    ----------
CORS
    前后端不同源，允许发送请求
        from fastapi.middleware.cors import CORSMiddleware
        
        origins = [
            "http://localhost.tiangolo.com",
            "https://localhost.tiangolo.com",
            "http://localhost",
            "http://localhost:8080",
        ]

        app.add_middleware(
            CORSMiddleware,
            allow_origins=origins,
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    支持以下参数：
        allow_origins - 一个允许跨域请求的源列表。例如 ['https://example.org', 'https://www.example.org']。你可以使用 ['*'] 允许任何源。
        allow_origin_regex - 一个正则表达式字符串，匹配的源允许跨域请求。例如 'https://.*\.example\.org'。
        allow_methods - 一个允许跨域请求的 HTTP 方法列表。默认为 ['GET']。你可以使用 ['*'] 来允许所有标准方法。
        allow_headers - 一个允许跨域请求的 HTTP 请求头列表。默认为 []。你可以使用 ['*'] 允许所有的请求头。Accept、Accept-Language、Content-Language 以及 Content-Type 请求头总是允许 CORS 请求。
        allow_credentials - 指示跨域请求支持 cookies。默认是 False。另外，允许凭证时 allow_origins 不能设定为 ['*']，必须指定源。
        expose_headers - 指示可以被浏览器访问的响应头。默认为 []。
        max_age - 设定浏览器缓存 CORS 响应的最长时间，单位是秒。默认为 600。
----------
APIRouter
    
    app.include_router(some_router)
    
    prefix、tags、responses 以及 dependencies 参数只是（和其他很多情况一样）FastAPI 的一个用于帮助你避免代码重复的功能。
        router = APIRouter(
            prefix="/items",  # 前缀不能以 / 作为结尾。
            tags=["items"],
            dependencies=[Depends(get_token_header)],
            responses={404: {"description": "Not found"}},
        )
        @router.get("/")
        async def read_items():
            return fake_items_db
        @router.get("/{item_id}")
        async def read_item(item_id: str):
            ...
        # 这个路径操作将包含标签的组合：["items"，"custom"]。
        # 并且在文档中也会有两个响应，一个用于 404，一个用于 403。
        # 一个来自router全局配置，一个来自自身单独配置
        @router.put(
            "/{item_id}",
            tags=["custom"],
            responses={403: {"description": "Operation forbidden"}},
        )
        async def update_item(item_id: str):
            ...
    在另一个 APIRouter 中包含一个 APIRouter
        router.include_router(other_router)
----------
SQL (Relational) Databases  # TODO
----------
BackgroundTasks
    使用
        from fastapi import BackgroundTasks

        def write_log(message: str):
            with open("log.txt", mode="a") as log:
                log.write(message)

        def get_query(background_tasks: BackgroundTasks, q: Optional[str] = None):  
            # FastAPI will also inject parameters from the request into your dependencies,
            # and include them into the OpenApi specification.
            if q: 
                print(id(q))  # same id
                message = f"found query: {q}\n"
                background_tasks.add_task(write_log, message)
            return q

        @app.post("/send-notification/{email}")
        async def send_notification(
            email: str, background_tasks: BackgroundTasks, q: str = Depends(get_query)
        ):
            print(id(q))  # same id
            message = f"message to {email}\n"
            background_tasks.add_task(write_log, message)
            return {"message": "Message sent"}
----------
设置 Swagger：
    
    可以使用参数 docs_url 设置它的 URL。
    可以通过设置 docs_url=None 禁用它。

    from fastapi import FastAPI

    app = FastAPI(docs_url="/documentation", docs_url=None)

    @app.get("/items/")
    async def read_items():
        return [{"name": "Foo"}]
----------
静态文件
    pip install aiofiles
    
    Import StaticFiles.
        "Mount" a StaticFiles() instance in a specific path.

        from fastapi import FastAPI
        from fastapi.staticfiles import StaticFiles

        app = FastAPI()

        app.mount("/static", StaticFiles(directory="static"), name="static")
        # name参数fastapi内部使用
    
    What is "Mounting"

        "Mounting" means adding a complete "independent" application in a specific path, that then takes care of handling all the sub-paths.

        This is different from using an APIRouter as a mounted application is completely independent.
        The OpenAPI and docs from your main application won't include anything from the mounted application, etc.
----------
测试
    # api
        @app.get("/")
        async def read_main():
            return {"msg": "Hello World"}
    # test
        from fastapi.testclient import TestClient
        from .main import app

        client = TestClient(app)

        def test_read_main():
            response = client.get("/")
            assert response.status_code == 200
            assert response.json() == {"msg": "Hello World"}
    client参数
        To pass a path or query parameter, add it to the URL itself.
        To pass a JSON body, pass a Python object (e.g. a dict) to the parameter 'json'.
        If you need to send Form Data instead of JSON, use the data parameter 'instead'.
        To pass headers, use a dict in the 'headers' parameter.
        For cookies, a dict in the 'cookies' parameter.
    执行
        $ pip install pytest
        $ pytest
----------
额外的状态码
    FastAPI 会自动使用默认的状态码或者使用你在 路径操作 中设置的状态码。
    如果你想要返回主要状态码之外的状态码，你可以通过直接返回一个 Response 来实现，比如 JSONResponse，然后直接设置额外的状态码。
    from fastapi.responses import JSONResponse

    app = FastAPI()

    items = {"foo": {"name": "Fighters", "size": 6}, "bar": {"name": "Tenders", "size": 3}}

    @app.put("/items/{item_id}")
    async def upsert_item(
        item_id: str, name: Optional[str] = Body(None), size: Optional[int] = Body(None)
    ):
        if item_id in items:
            item = items[item_id]
            item["name"] = name
            item["size"] = size
            return item  # 默认返回200
        else:
            item = {"name": name, "size": size}
            items[item_id] = item
            return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)  # 返回201
----------
直接返回响应
    当你创建一个 FastAPI 路径操作 时，你可以正常返回以下任意一种数据：dict，list，Pydantic 模型，数据库模型等等。
    FastAPI 默认会使用 jsonable_encoder 将这些类型的返回值转换成 JSON 格式
    然后，FastAPI 会在后台将这些兼容 JSON 的数据（比如字典）放到一个 JSONResponse 中，该 JSONResponse 会用来发送响应给客户端。

    你可以在你的 路径操作 中直接返回一个 JSONResponse。
    直接返回响应可能会有用处，比如返回自定义的响应头和 cookies。
    由于 FastAPI 不会对你返回的 Response 做任何改变，你必须确保你已经准备好响应内容。
    例如，如果不首先将 Pydantic 模型转换为 dict，并将所有数据类型（如 datetime、UUID 等）转换为兼容 JSON 的类型，则不能将其放入JSONResponse中。
        @app.put("/items/{id}")
        def update_item(id: str, item: Item):
            json_compatible_item_data = jsonable_encoder(item)
            return JSONResponse(content=json_compatible_item_data)
    修改响应头，返回xml
        from fastapi import FastAPI, Response
        app = FastAPI()

        @app.get("/legacy/")
        def get_legacy_data():
            data = """<?xml version="1.0"?>
            <shampoo>
            <Header>
                Apply shampoo here.
            </Header>
            <Body>
                You'll have to use soap here.
            </Body>
            </shampoo>
            """
            return Response(content=data, media_type="application/xml")

    当你直接返回 Response 时，它的数据既没有校验，又不会进行转换（序列化），也不会自动生成文档。
    但是你仍可以参考 OpenApI 中的额外响应 给响应编写文档。
        @app.get("/items/{item_id}", response_model=Item, responses={404: {"model": Message}})
        async def read_item(item_id: str):
            if item_id == "foo":
                return {"id": "foo", "value": "there goes my hero"}
            else:
                return JSONResponse(status_code=404, content={"message": "Item not found"}) 
----------
自定义响应
    ORJSONResponse
        如果你需要压榨性能，你可以安装并使用 orjson 并将响应设置为 ORJSONResponse
        参数 response_class 也会用来定义响应的「媒体类型」。    
        在这个例子中，HTTP 头的 Content-Type 会被设置成 application/json。
        from fastapi.responses import ORJSONResponse

        app = FastAPI()

        @app.get("/items/", response_class=ORJSONResponse)
        async def read_items():
            return [{"item_id": "Foo"}]
    HTML 响应
        参数 response_class 也会用来定义响应的「媒体类型」。
        在这个例子中，HTTP 头的 Content-Type 会被设置成 text/html。
        from fastapi.responses import HTMLResponse

        app = FastAPI()

        @app.get("/items/", response_class=HTMLResponse)
        async def read_items():
            return """
            <html>
                <head>
                    <title>Some HTML in here</title>
                </head>
                <body>
                    <h1>Look ma! HTML!</h1>
                </body>
            </html>
        """

    Response
        其他全部的响应都继承自主类 Response。
        你可以直接返回它。
        Response 类接受如下参数：
            content - 一个 str 或者 bytes。
            status_code - 一个 int 类型的 HTTP 状态码。
            headers - 一个由字符串组成的 dict。
            media_type - 一个给出媒体类型的 str，比如 "text/html"。
        可用响应
            Response
            HTMLResponse
            PlainTextResponse
            JSONResponse
            ORJSONResponse
            UJSONResponse
            RedirectResponse
            StreamingResponse  # 采用异步生成器或普通生成器/迭代器，然后流式传输响应主体。如果您有类似文件的对象（例如，由 open() 返回的对象），则可以在 StreamingResponse 中将其返回。
            FileResponse
----------
Additional Responses in OpenAPI  # TODO
----------
Response Cookie
    @app.post("/cookie/")
    def create_cookie():
        content = {"message": "Come to the dark side, we have cookies"}
        response = JSONResponse(content=content)
        response.set_cookie(key="fakesession", value="fake-cookie-session-value")
        return response
----------
Response Header
    @app.get("/headers/")
    def get_headers():
        content = {"message": "Hello World"}
        headers = {"X-Cat-Dog": "alone in the world", "Content-Language": "en-US"}
        return JSONResponse(content=content, headers=headers)
----------
Parameterized dependencies
    Let's imagine that we want to have a dependency that checks if the query parameter q contains some fixed content.
    But we want to be able to parameterize that fixed content.

    from fastapi import Depends, FastAPI

    app = FastAPI()


    class FixedContentQueryChecker:
        def __init__(self, fixed_content: str):
            self.fixed_content = fixed_content

        def __call__(self, q: str = ""):  # FastAPI will also inject parameters from the request into your dependencies, and include them into the OpenApi specification.
            if q:
                return self.fixed_content in q
            return False


    checker = FixedContentQueryChecker("bar")


    @app.get("/query-checker/")
    async def read_query_check(fixed_content_included: bool = Depends(checker)):
        return {"fixed_content_in_query": fixed_content_included}
----------
直接使用请求
    from fastapi import FastAPI, Request

    app = FastAPI()


    @app.get("/items/{item_id}")
    def read_root(item_id: str, request: Request):
        client_host = request.client.host
        return {"client_host": client_host, "item_id": item_id}
----------
Including WSGI - Flask, Django, others
    from fastapi import FastAPI
    from fastapi.middleware.wsgi import WSGIMiddleware  # 1
    from flask import Flask, escape, request

    flask_app = Flask(__name__)

    @flask_app.route("/")
    def flask_main():
        name = request.args.get("name", "World")
        return f"Hello, {escape(name)} from Flask!"

    app = FastAPI()

    @app.get("/v2")
    def read_main():
        return {"message": "Hello World"}

    app.mount("/v1", WSGIMiddleware(flask_app))  # 2

    Now, every request under the path /v1/ will be handled by the Flask application.
    If you run it with Uvicorn and go to http://localhost:8000/v1/ you will see the response from Flask:
        Hello, World from Flask!
    And if you go to http://localhost:8000/v2 you will see the response from FastAPI:
        {
            "message": "Hello World"
        }
----------
回调函数
    场景：
        外部调用create_invoice接口后，系统通过设置callbacks自动调用invoice_notification回调函数
    from fastapi import APIRouter, FastAPI
    from pydantic import BaseModel, HttpUrl

    app = FastAPI()

    class Invoice(BaseModel):
        id: str
        title: Optional[str] = None
        customer: str
        total: float

    class InvoiceEvent(BaseModel):
        description: str
        paid: bool

    class InvoiceEventReceived(BaseModel):
        ok: bool

    invoices_callback_router = APIRouter()  # 回调函数用的router


    @invoices_callback_router.post(
        "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
    )
    # The callback path can have an OpenAPI 3 expression that can contain parts of the original request(create_invoice) sent to your API.
    def invoice_notification(body: InvoiceEvent):
        pass


    @app.post("/invoices/", callbacks=invoices_callback_router.routes)  # pass the attribute .routes
    def create_invoice(invoice: Invoice, callback_url: Optional[HttpUrl] = None):
        return {"msg": "Invoice received"}
----------
环境变量
    你可以设置临时的环境变量针对一次函数调用
        # print_my_name.py
            name = os.getenv("MY_NAME", "World")
            print(f"Hello {name} from Python")    
        $ MY_NAME="Wade Wilson" python print_my_name.py
设置项
    读取环境变量，转换类型并校验数据
        from pydantic import BaseSettings

        class Settings(BaseSettings):
            app_name: str = "Awesome API"
            admin_email: str
            items_per_user: int = 50

    In some occasions it might be useful to provide the settings from a dependency, instead of having a global object with settings that is used everywhere.
    This could be especially useful during testing, as it's very easy to override a dependency with your own custom settings.
        from functools import lru_cache
        from fastapi import Depends, FastAPI
        from . import config
        app = FastAPI()

        @lru_cache()
        def get_settings():
            return config.Settings()

        @app.get("/info")
        async def info(settings: config.Settings = Depends(get_settings)):

    override settings during testing
        from fastapi.testclient import TestClient
        from . import config, main

        client = TestClient(main.app)

        def get_settings_override():
            return config.Settings(admin_email="testing_admin@example.com")

        main.app.dependency_overrides[main.get_settings] = get_settings_override

    .env
        class Settings(BaseSettings):
            app_name: str = "Awesome API"
            admin_email: str
            items_per_user: int = 50

            class Config:
                env_file = ".env"
----------
异步测试
    pip install pytest-asyncio
    pip install httpx

        import pytest
        from httpx import AsyncClient  # 类似requests，异步的

        from .main import app


        @pytest.mark.asyncio  # 告诉pytest这是个异步函数
        async def test_root():
            async with AsyncClient(app=app, base_url="http://test") as ac:
                response = await ac.get("/")
            assert response.status_code == 200
            assert response.json() == {"message": "Tomato"}
----------
Events: startup - shutdown
    可以在应用启动前或者关闭的时候定义事件处理器
        app = FastAPI()

        items = {}

        @app.on_event("startup")
        async def startup_event():
            items["foo"] = {"name": "Fighters"}
            items["bar"] = {"name": "Tenders"}

        @app.on_event("shutdown")
        def shutdown_event():
            with open("log.txt", mode="a") as log:
                log.write("Application shutdown")

        @app.get("/items/{item_id}")
        async def read_items(item_id: str):
            return items[item_id]
----------
WebSocket
    from fastapi import WebSocket
    class ConnectionManager:
        def __init__(self):
            self.active_connections: List[WebSocket] = []

        async def connect(self, websocket: WebSocket):
            await websocket.accept()
            self.active_connections.append(websocket)

        def disconnect(self, websocket: WebSocket):
            self.active_connections.remove(websocket)

        async def send_personal_message(self, message: str, websocket: WebSocket):
            await websocket.send_text(message)

        async def broadcast(self, message: str):
            for connection in self.active_connections:
                await connection.send_text(message)

    @app.websocket("/ws/{client_id}")  # url
    async def websocket_endpoint(websocket: WebSocket, client_id: int):  # 定义普通的路径操作函数
        await manager.connect(websocket)
        try:
            while True:
                data = await websocket.receive_text()
                await manager.send_personal_message(f"You wrote: {data}", websocket)
                await manager.broadcast(f"Client #{client_id} says: {data}")
        except WebSocketDisconnect:
            manager.disconnect(websocket)
            await manager.broadcast(f"Client #{client_id} left the chat")
    # When a WebSocket connection is closed,
    # the await websocket.receive_text() will raise a WebSocketDisconnect exception
----------
Behind a Proxy
    In some situations, you might need to use a proxy server like Traefik or Nginx with a configuration that adds an extra path prefix that is not seen by your application.
    Having a proxy with a stripped path prefix,
    in this case, means that you could declare a path at /app in your code,
    but then, you add a layer on top (the proxy) that would put your FastAPI application under a path like /api/v1.
    In this case, the original path /app would actually be served at /api/v1/app.
    Even though all your code is written assuming there's just /app.
    And the proxy would be "stripping" the path prefix on the fly before transmitting the request to Uvicorn, keep your application convinced that it is serving at /app, so that you don't have to update all your code to include the prefix /api/v1.

    Up to here, everything would work as normally.

    But then, when you open the integrated docs UI (the frontend), it would expect to get the OpenAPI schema at /openapi.json, instead of /api/v1/openapi.json.

    So, the frontend (that runs in the browser) would try to reach /openapi.json and wouldn't be able to get the OpenAPI schema.

    Because we have a proxy with a path prefix of /api/v1 for our app, the frontend needs to fetch the OpenAPI schema at /api/v1/openapi.json.
    By use root_path
        uvicorn main:app --root-path /api/v1
        or app = FastAPI(root_path="/api/v1")

    Uvicorn will expect the proxy to access Uvicorn at http://127.0.0.1:8000/app, and then it would be the proxy's responsibility to add the extra /api/v1 prefix on top.
----------
HTTPS
    流程
        https://howhttps.works/the-handshake/

    HTTP/SSL/TLS
        SSL is the original and now deprecated protocol created at Netscape in the mid 90s.
        TLS is the new protocol for secured encryption on the web maintained by IETF.
        SSL was renamed to TLS

        HTTPS is just the HTTP protocol but with data encryption using SSL/TLS.

    It is a common practice to have one program/HTTP server running on the server(the machine, host, etc.) and managing all the HTTPS parts:
        sending the decrypted HTTP requests to the actual HTTP application running in the same server (the FastAPI application, in this case),
        take the HTTP response from the application, encrypt it using the appropriate certificate and sending it back to the client using HTTPS.
        This server is often called a TLS Termination Proxy.
    
     Let's Encrypt is a project from the Linux Foundation. It provides HTTPS certificates for free.