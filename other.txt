----------
cloc: 统计代码行数
----------
screen -ls 列出screen
screen -S name 新建screen
screen -r name 登入screen
ctrl a + c 新建tab
ctrl a + d 从当前screen返回
不进入screen删除: screen -S session_name -X quit
进入screen输入exit删除
ctrl a + n & p next & prev: 切换上一个下一个tab
----------
git diff HEAD HEAD~1: 查看上一次提交的改动
git push origin -d somebranch 删除远程分支
git 通过 comment 关键字查找commit: git log --grep=keyword
git 查看某次commit内容: git show commitID
当我想从远程仓库里拉取一条本地不存在的分支时：
    git checkout -b 本地分支名 upstream/远程分支名
这个将会自动创建一个新的本地分支，并与指定的远程分支关联起来。

创建远程分支并把本地分支推到远程分支:
    git push upstream hotfix:tbox_account_hotfix
删除远程分支:
    git push upstream -d tbox_account_hotfix

Git revert到某一个commit:

# Revert to the specific revision using git reset
::
    Here we first hard reset the state of the repository to some previous revision and then soft reset back to current state.
    The soft reset will keep file modifications, so it will bring old state back on top of the current state:
        # Careful, reset --hard will remove non-commited changes
        **$ git reset --hard 0682c06**  # Use the SHA1 of the revision you want to revert to
        HEAD is now at 0682c06 G3
        **$ git reset --soft HEAD@{1}**
        **$ git commit -m "Reverting to the state of the project at 0682c06"**

# Revert to the specific revision using git read-tree
::
    **git read-tree -um @ 0682c06**  # Use the SHA1 of the revision you want to revert to
    **git commit -m "Reverting to the state of the project at 0682c06"**
    The -m option instructs read-tree to merge the specified state and -u will update work tree with the results of the merge.
----------
vscode:
    ctrl+z undo { "key": "cmd+y", "command": "redo", "when": "editorTextFocus" }
    插件: Paste and Indent, One Dark Pro, Python, vscode-icons
{
    "workbench.iconTheme": "vscode-icons",
    "workbench.startupEditor": "newUntitledFile",
    "vsicons.dontShowNewVersionMessage": true,
    "editor.fontSize": 14,
    "workbench.colorTheme": "One Dark Pro",
    "python.linting.pylintArgs": [
        "--load-plugins",
    ],
    "workbench.activityBar.visible": true,
    "python.linting.flake8Enabled": true,
    "python.formatting.provider": "autopep8",
    "pasteAndIndent.selectAfter": true,
}
----------
zsh: alias | grep git 查看git简写
----------
python -m SimpleHTTPServer [port]  # 当前目录开启一个小的文件服务器, 默认端口8000
# 另外，python 3,中是 python -m http.server
----------
python -m this               # python's Zen
python -m calendar           # 显示一个日历
echo '{"json":"obj"}' | python -mjson.tool  # 漂亮地格式化打印json数据
echo '{"json":"obj"}' | python -mjson.tool | pygmentize -l json # 高亮地打印json格式化
python -m antigravity       # 这个该自己试试
----------
git本地没有远程某个分支
    git branch -va: 查看本地和远程分支
    git checkout -t upstream/test: 能够直接新建本地分支，将远程分支提取出来。
----------
组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。
----------
git 提交一个空目录: 这种情况下只需要在目录下创建.gitkeep文件，然后在项目的.gitignore中设置不忽略.gitkeep。
----------
mysql中用 <> 与 != 都是可以的，但sqlserver中不识别 != ,所以建议用 <> 。
mysql truncate table 表名; 清除表的数据。
----------
#http协议版本
http1.0：当前浏览器客户端与服务器端建立连接之后，只能发送一次请求，一次请求之后连接关闭。
http1.1：默认使用长连接，当前浏览器客户端与服务器端建立连接之后，可以在一次连接中发送多次请求。（基本都使用1.1）
----------
#请求资源
URL： 统一资源定位符。http://localhost:8080/WebRoot/hello。只能定位互联网资源。是URI 的子集。URL=协议+主机端口+URI
URI： 统一资源标记符。/WebRoot/hello。用于标记任何资源。可以是本地文件系统、局域网的资源、可以是互联网资源。
----------
redis zadd(name, key, score): 有序集合，和集合都是成员是唯一的。zrangebyscore(name, min, max): 返回score在min和max之间的key。
redis hmget(name, keys): 获取给定keys的值，key的顺序对应值顺序。
----------
Renaming a virtualenv folder without breaking it:
    1. cpvirtualenv oldenv newenv
    2. rmvirtualenv oldenv
----------
Mac窗口工具: spectacleapp
----------
docker cp
cp Copy files/folders between a container and the local filesystem
在容器和本地文件系统之间复制文件/文件夹

Usage:  docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-
从容器中复制文件或目录到执行命令所在机器的指定路径
        docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH
从执行命令所在的机器复制文件或目录到容器内部的指定路径
|-: 使用复制文件的文件名
----------
scp 从本地复制到远程
    scp local_file remote_username@remote_ip:remote_folder
从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可
----------
mysql 创建数据库名字带-的情况: `dbname`
----------
分布式文件系统
::
    在信息爆炸时代，单纯通过增加硬盘个数来扩展计算机文件系统的存储容量的方式，在容量大小、容量增长速度、数据备份、数据安全等方面的表现都差强人意。分布式文件系统可以有效解决数据的存储和管理难题：将固定于某个地点的某个文件系统，扩展到任意多个地点/多个文件系统，众多的节点组成一个文件系统网络。每个节点可以分布在不同的地点，通过网络进行节点间的通信和数据传输。人们在使用分布式文件系统时，无需关心数据是存储在哪个节点上、或者是从哪个节点从获取的，只需要像使用本地文件系统一样管理和存储文件系统中的数据。
----------