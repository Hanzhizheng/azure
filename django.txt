django使用upate是要优于save方式的.

update() is converted directly to an SQL statement; it doesn't call save() on the model instances, and so the pre_save and post_save signals aren't emitted. If you want your signal receivers to be called, you should loop over the queryset, and for each model instance, make your changes and call save() yourself.

django 上传文件xlrd处理
serializer = self.get_serializer(data=request.data)
serializer.is_valid(raise_exception=True)
ifile = serializer.validated_data['ifile']
workbook = xlrd.open_workbook(filename=None, file_contents=ifile.read())

理解aggregate的关键在于理解SQL中的聚合函数：以下摘自百度百科：SQL基本函数，聚合函数对一组值执行计算，并返回单个值。除了COUNT以外，聚合函数都会忽略空值。常见的聚合函数有AVG/COUNT/MAX/MIN/SUM等
>>> from django.db.models import Count
>>> pubs = Publisher.objects.aggregate(num_books=Count('book'))
>>> pubs
{'num_books': 27}
aggregate的逻辑比较简单，应用场景比较窄，如果你想要对数据进行分组（GROUP BY）后再聚合的操作，则需要使用annotate来实现，Annotate 对于 queryset 中的每个值在指定的属性上进行汇总, 相当于group_by. mysql 分组之后如何统计记录条数? gourp by 之后的 count 把group by查询结果当成一个表再count一次

根据车辆运行状态字段(choices)统计各个choice的数量:
In [30]: models.Truck.objects.values('vehicle_running_status').annotate(count=Count('vehicle_running_status'))
Out[30]: [{'count': 974, 'vehicle_running_status': u'offline'}, {'count': 2128, 'vehicle_running_status': u'alerting'}, {'count': 37, 'vehicle_running_status': u'charging'}, {'count': 39, 'vehicle_running_status': u'driving'}, {'count': 63, 'vehicle_running_status': u'stopped'}]

Restframework:
ipdb> models.Truck.objects.all().values('finance_type').annotate(Count('finance_type'))
[{'finance_type__count': 6, 'finance_type': u'0'}, {'finance_type__count': 1, 'finance_type': u'4'}, {'finance_type__count': 1, 'finance_type': u'3'}, {'finance_type__count': 1, 'finance_type': u'2'}]

ipdb> queryset.values('finance_type').annotate(Count('finance_type')).order_by('finance_type')
[{'finance_type__count': 6, 'finance_type': u'0'}, {'finance_type__count': 1, 'finance_type': u'2'}, {'finance_type__count': 1, 'finance_type': u'3'}, {'finance_type__count': 1, 'finance_type': u'4'}]
----------
In [17]: truck_model.truck_set.values_list('vin')
Out[17]: [(u'LGHB2V190FC200001',), (u'HBLDZO973WO781300',)]

In [18]: truck_model.truck_set.values_list('vin', flat=True)
Out[18]: [u'LGHB2V190FC200001', u'HBLDZO973WO781300']

filter不等于筛选
from django.db.models import Q  
myapps = App.objects.filter(~Q(name=''))

django-rest-swagger
You can prevent django-rest-swagger from using any serializer:
    omit_serializer: true

omit_parameters:
  - query
parameters_strategy:
  form: replace

models.CASCADE: 默认为models.CASCADE, 级联删除. 当删除'一'时, '多'会被删除.

执行collectstatic命令会把静态文件拷贝到你设置的static_root目录下.
利用前缀STATIC_URL的具体内容,来映射STATIC_ROOT

values, values_list remove duplicate:
    Entity.objects.order_by('foreign_key').values('foreign_key').distinct()

change DateField to DateTimeField可以直接改

----------
django: How to get objects from a ContentType instance:

    As ContentType model has three fields app_label, model and name. So you can easily filter through these fields.

    notifications = Notification.objects.filter(content_type__model='Comment', object_id=1)

    Example model:

    class Notification(models.Model):
        content_type = models.ForeignKey(ContentType, related_name='notifications', on_delete=models.CASCADE)
        object_id = models.PositiveIntegerField(_('Object id'))
        content_object = GenericForeignKey('content_type', 'object_id')
----------
如果启用了SessionAuthenticationMiddleware, 修改密码将会使该用户的所有会话失效

在DEBUG设置为False时，也就是线上环境时，Django项目里的静态文件（js\css\plugins）会无法使用。这是，需要运行python manage.py collectstatic，将静态文件统一收集到一个目录下。STATIC_ROOT配置的就是该目录的绝对路径
STATICFILES_DIRS: 定义额外的静态文件搜索地址
STATIC_URL 和 MEDIA_URL 必须以斜杠“/”结束。
python manage.py dbshell: 指定打开某个数据库的shell, 默认为default。
python manage.py flush: 从数据库中删除所有数据。已应用的迁移不会被清除。只删除具体数据，不删除数据表！

STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)
FileSystemFinder：在文件系统里搜索STATICFILES_DIRS指定目录，默认不包含任何目录。
AppDirectoriesFinder：搜索INSTALLED_APPS注册过的应用目录。
----------
django BinaryField 返回:
    "TextField": "232304014c47484232563139304643323030303031010006120a1e093a3559",
    "BinaryField": "MjMyMzA0MDE0YzQ3NDg0MjMyNTYzMTM5MzA0NjQzMzIzMDMwMzAzMDMxMDEwMDA2MTIwYTFlMDkzYTM1NTk="

response会返回经b64encode编码过的值；后台admin看不到模型的BinaryField字段；
----------
django_filters:
    MultipleChoiceFilter
        The same as ChoiceFilter except the user can select multiple choices and the filter will form the OR of these choices by default to match items. The filter will form the AND of the selected choices when the conjoined=True argument is passed to this class.
        Multiple choices are represented in the query string by reusing the same key with different values (e.g. ‘’?status=Regular&status=Admin’‘).
----------
django-simple-history:
save_without_historical_record:
    class Poll(models.Model):
    question = models.CharField(max_length=200)
    history = HistoricalRecords()

    def save_without_historical_record(self, *args, **kwargs):
        self.skip_history_when_saving = True
        try:
            ret = self.save(*args, **kwargs)
        finally:
            del self.skip_history_when_saving
        return ret


    poll = Poll(question='something')
    poll.save_without_historical_record()
----------
Change Reason:
    poll = Poll(question='Question 1')
    poll.changeReason = 'Add a question'
    poll.save()
----------
To alter the default permissions given to model (i.e. add, change and delete), you can use a model's meta class default_permissions field. In addition, you can add custom permissions to a model permissions through a model's meta class permissions field.
class Store(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=30,unique=True)
    city = models.CharField(max_length=30)
    state = models.CharField(max_length=2)
    class Meta:
        default_permissions = ('add',)
        permissions = (('give_refund','Can refund customers'),('can_hire','Can hire employees'))
----------
django reuse app: python setup.py bdist_wheel后，新项目设置app，url之后makemigrations, migrate，不需要考虑reuse app的迁移文件，新项目迁移独立而不是复用:
新项目 ➜  migrations ls
0001_initial.py             0002_auto_20181128_0912.py  0003_r1_sex.py              __init__.py
reuse app ➜  migrations ls
0001_initial.py             0002_r1_age.py              0003_r1_sex.py              __init__.py
----------
查看 Django queryset 执行的 SQL: print str(Author.objects.all().query)
----------
restframework自定义字段:
class CustomField(serializers.Field):
    def get_attribute(self, instance):
        # （序列化时）从模型实例中取一个值给这个字段处理,也可以使用`source`参数指定
        return instance.key

    def get_value(self, dictionary):
        # （反序列化时）从传入数据中提取一个值给这个字段处理
        return super(CustomField, self).get_value(dictionary)

    def to_representation(self, value):
        # （序列化时）处理出来的数据用来序列化显示
        return value.url

    def to_internal_value(self, data):
        # （反序列化时）处理接收到的数据
        return data['key']
----------
from django.db import models

class Users(models.Model):
    pass

class Sample(models.Model):
    users = models.ManyToManyField(Users)

Users().save()
Users().save()

# Access the through model directly
ThroughModel = Sample.users.through

users = Users.objects.filter(pk__in=[1,2])

sample_object = Sample()
sample_object.save()

ThroughModel.objects.bulk_create([
    ThroughModel(users_id=users[0].pk, sample_id=sample_object.pk),
    ThroughModel(users_id=users[1].pk, sample_id=sample_object.pk)
])
传统能源例子:
    class TruckSerie(DeletedMixin, BaseModel):
        truck_classes = models.ManyToManyField(
            'owl.TruckClass',
            verbose_name=u'品系',
            blank=True,
            help_text=u'品系',
        )

    tm = models.TruckSerie.truck_classes.through
    In [61]: print tm.objects.bulk_create([tm(truckclass_id=1,truckserie_id=1),tm(truckclass_id=2,truckserie_id=1)])
    [<TruckSerie_truck_classes: TruckSerie_truck_classes object>, <TruckSerie_truck_classes: TruckSerie_truck_classes object>]

    In [62]: models.TruckSerie.objects.first().truck_classes.all()
    Out[62]: [<TruckClass: test>, <TruckClass: test1>]
----------
django unittest 传参数:

    post(path, data=None, content_type=MULTIPART_CONTENT, follow=False, secure=False, **extra)
    >>> c = Client()
    >>> c.post('/login/', {'name': 'fred', 'passwd': 'secret'})

    get(path, data=None, follow=False, secure=False, **extra)
    >>> c = Client()
    >>> c.get('/customers/details/', {'name': 'fred', 'age': 7})
----------
from django.core import management
management.call_command('flush')
----------
To get the list of likes this Comment received you must use the ContentType class:

from django.contrib.contenttypes.models import ContentType

# Pass the instance we created in the snippet above
ct = ContentType.objects.get_for_model(comment)

# Get the list of likes
Activity.objects.filter(content_type=ct, object_id=comment.id, activity_type=Activity.LIKE)
----------
restframework custom router:  注意变量routes顺序，否则可能发生404，405；注意url的pattern。
from rest_framework.routers import (
    Route,
    DynamicDetailRoute,
    SimpleRouter,
    DefaultRouter,
    DynamicListRoute,
)


class CustomRouter(DefaultRouter):
    routes = [
        Route(
            url=r'^{prefix}{trailing_slash}$',
            mapping={'get': 'list'},
            name='{basename}-list',
            initkwargs={'suffix': 'List'}
        ),
        DynamicListRoute(
            url=r'^{prefix}/{methodname}{trailing_slash}$',
            name='{basename}-{methodnamehyphen}',
            initkwargs={}
        ),
        Route(
            url=r'^{prefix}/{lookup}{trailing_slash}$',
            mapping={
                'get': 'retrieve',
                'patch': 'partial_update',
                'delete': 'destroy'
            },
            name='{basename}-detail',
            initkwargs={'suffix': 'Instance'}
        ),
        DynamicDetailRoute(
            url=r'^{prefix}/{lookup}/{methodname}{trailing_slash}$',
            name='{basename}-{methodnamehyphen}',
            initkwargs={}
        ),
    ]

----------
默认情况下，LOGGING设置与Django的默认logging设置进行合并。
如果Logging中的disable_existing_loggers键为True(默认值)，那么默认配置中的所有logger都将禁用。Logger的禁用与删除不同；logger仍然存在，但是将默默丢弃任何传递给它的信息，也不会传播给上一级logger。所以，你应该非常小心使用'disable_existing_loggers'：True，它可能不是你想要的。你可以设置disable_existing_loggers为False，并重新定义部分或所有的默认loggers，或者你可以设置LOGGING_CONFIG为None，并自己处理logging配置。

默认情况下，Django的logging配置如下，

当DEBUG为True时，
    a. 全局logger'django'会向控制台发送级别等于或高于INFO的所有消息。
当DEBUG为False时，
    a. 全局logger'django'会向AdminEmailHandler发送ERROR或者CRITICAL级别的消息。
其它，和DEBUG值无关，
    a. logger'django.server'会发送所有INFO或者更高级别的消息给控制台。
----------
模型非必填，swagger改变必填非必填状态，默认必填required=True，非必填required=False:
    main_factory = serializers.PrimaryKeyRelatedField(
        queryset=models.MainFactory.objects.filter(deleted=False),
        help_text=u'主机厂(int)',
    )
    vin = serializers.CharField(
    )
----------
列举django orm中三种能写sql语句的方法:
    1. 使用extra：查询人民邮电出版社出版并且价格大于50元的书籍
        Book.objects.filter(publisher__name='人民邮电出版社').extra(where=['price>50'])
    2. 使用raw
        books=Book.objects.raw('select * from hello_book')
        for book in books:
           print book
    3. 自定义sql
        from django.db import connection
        cursor = connection.cursor()

        cursor.execute("insert into hello_author(name) VALUES ('郭敬明')")
        cursor.execute("update hello_author set name='韩寒' WHERE name='郭敬明'")
        cursor.execute("delete from hello_author where name='韩寒'")

        cursor.execute("select * from hello_author")
        cursor.fetchone()
        cursor.fetchall()
--------
DATABASES = {
        'default': {
            ...
            'ATOMIC_REQUESTS': True,
        }
    }
同一个http请求对应的所有sql都放在一个事务中执行，要么所有都成功，要么所有都失败，是全局性的配置，如果要对某个http请求放水，然后自定义事务，
可以用non_atomic_requests修饰器

    from django.db import transaction

    class xxx(xxxView):
        @transaction.non_atomic_requests
        def post(self, request, *args, **kwargs):
            ...
----------
Whenever you log an exception, it’s usually helpful to log the stack trace of the exception. Python’s logging module supports this:
    1 Logger.exception() automatically includes the traceback and logs at ERROR level. . .
    2 For other log levels, use the optional exc_info keyword argument.
e.g:
    import logging
    import requests
    logger = logging.getLogger(__name__)
    def get_additional_data():
    try:
        r = requests.get("http://example.com/something-optional/")
    except requests.HTTPError as e:
        logger.exception(e)
        logger.debug("Could not get additional data", exc_info=True)
        return None
    return r
----------
BinaryField: remember that binary data can come in huge chunks, which can slow down databases. If this occurs and becomes a bottleneck(瓶颈), the solution might be to save the binary data in a file and reference it with a FileField.
----------
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': config.default_db.db_name,
        'USER': config.default_db.db_user,
        'PASSWORD': config.default_db.db_password,
        'HOST': config.default_db.db_host,
        'PORT': '3306',
        'OPTIONS': {
            'charset': 'utf8mb4',
            'use_unicode': True,
        },
        'TEST': {
            'CHARSET': 'utf8mb4',
            'COLLATION': 'utf8mb4_bin',
        },
    }
}
utf8mb4_bin 大小写敏感
----------
遵守“不测试常量”规则，单元测试要测试的其实是逻辑、流程控制和配置。
----------
Book.object.all().only('name'), id始终会查, 如果取price, 发生了什么? 它会再次查询数据库,对数据库造成压力.
----------
Django provides a method_decorator to use decorators with class based views.
from django.utils.decorators import method_decorator
----------
You can reduce memory consumption through use of iterator method:
    for article in Article.objects.select_related('author').iterator()
----------
migrate 使用--fake参数：--fake只会将迁移脚本的版本号记录到django_migrations中，而并不会执行这个迁移脚本。所以如果是数据库中的表和模型都已经完成了映射，但是版本号对不上，那么可以使用这种方式解决。
----------
class A(models.Model):
    x = models.BooleanField(default=True)

class B(models.Model):
    y = models.ManyToManyField(A)

class C(models.Model):
    z = models.ForeignKey(A)
In this scenario, C.objects.all().prefetch_related('z__b_set') doesn't work.

C.objects.all().select_related('z').prefetch_related('z__b_set') work.
----------
select_related()的效率要高于prefetch_related()。因此，最好在能用select_related()的地方尽量使用它，也就是说，对于ForeignKey字段，避免使用prefetch_related()。
----------
Django Debug Toolbar In Rest Api:
setting:
    if DEBUG:
        COMPRESS_ROOT = STATIC_ROOT
        COMPRESS_URL = STATIC_URL
        MIDDLEWARE_CLASSES += ('debug_toolbar.middleware.DebugToolbarMiddleware',)
        INTERNAL_IPS = ('127.0.0.1',)
        INSTALLED_APPS += ( 'debug_toolbar',)
        DEBUG_TOOLBAR_CONFIG = {
            "JQUERY_URL": '//cdn.bootcss.com/jquery/2.2.4/jquery.min.js',
        }
url:
    if settings.DEBUG:
        import debug_toolbar
        urlpatterns = [
            url(r'^__debug__/', include(debug_toolbar.urls)),
        ] + urlpatterns

django debug toolbar 对于json数据、gzip数据是不会返回toolbar的，在写api的时候，通常都会返回gzip的json数据，因此我们需要做一些改进:

# -*- coding: utf-8 -*-
from cStringIO import StringIO
import gzip
from django.http import HttpResponse

class DebugToolbar4JsonMiddleware(object):
    RESPONSE_TYPES = ('application/json',)

    def process_response(self, request, response):
        if 'gzip' in response.get('Content-Encoding', ''):
            sio = StringIO(response.content)
            f = gzip.GzipFile(fileobj=sio)
            content = f.read()
            f.close()
        else:
            content = response.content

        if response.get('Content-Type', '').split(';')[0] in self.RESPONSE_TYPES:
            return HttpResponse(
                '''
                <html><body>
                  <script>
                    var data = %s;
                    document.write("<pre>");
                    document.write(JSON.stringify(data, null, 4));
                    document.write("</pre>");
                  </script>
                </body></html>''' % content
            )
        return response


将该middleware中加入到settings.py中，注意：确保该middleware在 debug_toolbar.middleware.DebugToolbarMiddleware 的后面。

使用 django-debug-panel 可以debug post api:

Install and configure Django Debug Toolbar

1. Install Django Debug Panel:
    pip install django-debug-panel
2. Add debug_panel to your INSTALLED_APPS setting:
    INSTALLED_APPS = (
        # ...
        'debug_panel',
    )
3. Replace the Django Debug Toolbar middleware with the Django Debug Panel one. Replace:
    MIDDLEWARE_CLASSES = (
        ...
        'debug_toolbar.middleware.DebugToolbarMiddleware',
        ...
    )
    with:
    MIDDLEWARE_CLASSES = (
        ...
        'debug_panel.middleware.DebugPanelMiddleware',
        ...
    )
    with django-debug-panel, 'owl.common.middleware.DebugToolbar4JsonMiddleware' not need.

4. Install the Chrome extension Django Debug Panel

add Profiling
    Path: debug_toolbar.panels.profiling.ProfilingPanel
----------
In some cases, two queries may perform much better than one; you can get the ids from the first query and pass them into the second query:
    tag_ids = (Post.objects.all().values_list('id', flat=True).distinct())
    tags = Tag.objects.filter(id__in=tag_ids)
----------
If the properties are accessedmorethan once per request, you can optimize them with memoization
from django.utils.functional import cached_property
class TheModel(models.Model):
    ...
    @cached_property
    def expensive(self):
        # expensive computation of result
        return result
----------
from django.db.models import Prefetch
Using Prefetch allows us to define the queryset for the prefetch. This means we can use select_related() to merge the comments and comments__author queries into one.
queryset = (
    BlogPost.objects.prefetch_related(
        Prefetch(
                'comments', queryset=Comment.objects.select_related('author')
        )
    )
)
----------
Django 设置了三个内置的 loggers。

django 是用来捕捉所有输出的记录器。没有消息会直接发送到这个记录器上。

django.request 记录与 request 请求处理相关的消息。5XX 的返回会触发 ERROR 消息的记录；4XX 的返回会触发 WARNING 消息的记录。这一记录器的拥有下面两个额外内容：status_code 和 request。

django.db.backends 记录代码中与数据库交互有关的消息。比如，每个 request 请求触发的 SQL 语句执行时都会被以 DEBUG 级别的消息交给 logger 处理。这一记录器拥有下面的额外内容：duration, sql, params.

出于性能的考虑，SQL 记录器只有在 settings.DEBUG 设置为 True 时才有效，此时不管日志级别的任何设置。
----------
    The 'disable_existing_loggers': True statement at the top of LOGGING disables Django's default logging configuration. This guarantees (确保) no default logging behavior is applied to a Django project.

An alternative to disabling Django default logging behavior is to override the default logging definitions on an individual basis, as any explicit LOGGING configuration in settings.py takes precedence over Django defaults even when 'disable_existing_loggers': False.

Notice if you want to use default filters or something else, the same default filters need to be re-declared, since the default filters are lost when 'disable_existing_loggers': True.


LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse',
        },
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'formatters': {
        'simple': {
            'format': '[%(asctime)s] %(levelname)s %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        },
        'verbose': {
            'format': '[%(asctime)s] %(levelname)s [%(name)s.%(funcName)s:%(lineno)d] %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        },
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'development_logfile': {
            'level': 'DEBUG',
            'filters': ['require_debug_true'],
            'class': 'logging.FileHandler',
            'filename': '/tmp/django_dev.log',
            'formatter': 'verbose'
        },
        'production_logfile': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/django/django_production.log',
            'maxBytes' : 1024*1024*100, # 100MB
            'backupCount' : 5,
            'formatter': 'simple'
        },
        'dba_logfile': {
            'level': 'DEBUG',
            'filters': ['require_debug_false','require_debug_true'],
            'class': 'logging.handlers.WatchedFileHandler',
            'filename': '/var/log/dba/django_dba.log',
            'formatter': 'simple'
        },
    },
    'root': {
        'level': 'DEBUG',
        'handlers': ['console'],
    },
    'loggers': {
        'coffeehouse': {
            'handlers': ['development_logfile','production_logfile'],
         },
        'dba': {
            'handlers': ['dba_logfile'],
        },
        'django': {
            'handlers': ['development_logfile','production_logfile'],
        },
        'py.warnings': {
            'handlers': ['development_logfile'],
        },
    }
}


   There's the root key, which although declared outside of the loggers section, is actually the root logger for all loggers. The root key tells Django to process messages from all loggers -- whether declared or undeclared in the configuration -- and handle them in a given in way. In this case, root tells Django that all log messages -- since the DEBUG level includes all messages -- generated by any logger (coffeehouse, dba, django, py.warnings or any other) be processed by the console handler.
----------
Set up a Django application to use Sentry
To use Sentry in a Django project you require a package called Raven to establish (建立) communication between the two parties. Simply do pip install raven to install the latest Raven version.

Once you install Raven, you must declare it in the INSTALLED_APPS list of your project's settings.py file as illustrated in listing 5-19. In addition, it's also necessary to configure Raven to communicate with a specific Sentry project via a DSN value, through the RAVEN_CONFIG variable also shown in listing 5-19.

Listing 5-19 Django project configuration to communicate with Sentry via Raven

INSTALLED_APPS = [
    ...
    'raven.contrib.django.raven_compat',
    ...
]

RAVEN_CONFIG = {
    'dsn': '<your_dsn_value>@sentry.io/<your_dsn_value>',
}

As you can see in listing 5-19, the RAVEN_CONFIG variable should declare a dsn key with a value corresponding to (与…相一致) the DSN value from the Sentry project that's to receive the log messages.

After you set up this minimum Raven configuration, you can send a test message running the python manage.py raven test command from a Django project's command line. If the test is successful, you will see a test message in the Sentry dashboard presented in Sentry SaaS project dashboard.

Once you confirm communication between your Django project and Sentry is successful, you can set up Django logging to send log messages to Sentry. To Django's logging mechanism, Sentry is seen as any other handler (e.g. file, stream), so you must first declare Sentry as a logging handler using the raven.contrib.django.handlers.SentryHandler class, as illustrated in listing 5-20.

Listing 5-20 Django logging handler for Sentry/Raven

LOGGING = {
...
 'handlers': {
       ....
        'sentry': {
            'level': 'ERROR',
            'class': 'raven.contrib.django.handlers.SentryHandler',
        },
       ...
  }
The sentry handler in listing 5-20 tells Django to handle log messages with an ERROR level through Sentry. Once you have a Sentry handler, the last step is to use the sentry handler on loggers to assign which packages/loggers get processed through Sentry.
----------
An exception is that if CharField has both unique=True and blank=True then null=True is also required to avoid unique constraint (限制) violations (违反) when saving multiples objects with blank values.
----------
Django automatically creates an index for all models.ForeignKey columns.
----------
使用Vary头部信息
django默认使用请求路径和查询作为缓存关键字，比如/stories/2005/?order_by=author，这意味着所有请求该url的请求都是用同一个缓存页面，如果这个页面是根据不同的请求头部信息而生成不一样的页面的时候，你需要使用Vary头部去告诉缓存机制要根据这些不同的头部信息输出不同的内容。
为了做到这一点，django提供了vary_on_header视图装饰器
.. code:: python
    from django.views.decorators.vary import vary_on_headers

    @vary_on_headers('User-Agent')
    def my_view(request):
        # ...
上面的这个例子，django的缓存机制会为每一个user-agent缓存一个单独的页面。
vary_on_header装饰器接受多个参数，比如Cookie和User-Agent，多个参数之间是组合关系；
----------
自定义renderer下载文件:

views:
.. code:: python
    from rest_framework.enderers import BaseRenderer
    from rest_framework.response import Response
    from rest_framework import generics


    class BinaryFileRenderer(BaseRenderer):
        media_type = 'application/octet-stream'
        format = None
        charset = None
        render_style = 'binary'

        def render(self, data, media_type=None, renderer_context=None):
            return data


    class FileauthView(generics.GenericAPIView):
        renderer_classes = (BinaryFileRenderer,)

        def get(self, request, *args, **kwargs):
            with open('./.well-known/pki-validation/fileauth.txt', 'rb') as report:
                return Response(
                    report.read(),
                    headers={'Content-Disposition': 'attachment; filename="fileauth.txt"'},
                    content_type='text/plain')
urls:
.. code:: python
    url(r'^.well-known/pki-validation/fileauth.txt/',
        FileauthView.as_view(),
    ),
----------
uwsgi --http :7799 --wsgi-file owl/wsgi.py -H ~/.virtualenvs/dfjk --http-timeout 3600 -L --log-4xx --workers 4
    --http-socket = 127.0.0.1:8080: 指定ip地址
    -H | --virtualenv: set PYTHONHOME/virtualenv
    --http-timeout: 设置超时时间
    -L | --disable-logging: disable request logging
    --log-4xx: enable 4xx status request logging, --log-5xx and so on.

    --log-drain r'notification.*200'
    --log-drain: drain (do not show) log lines matching the specified regexp
    --log-filter: show only log lines matching the specified regexp

    --log-format: "%(method) %(host)%(uri) %(status) in %(msecs) ms"

In nginx:
    uwsgi_read_timeout: 默认60秒，nginx等待uwsgi进程发送响应数据的超时时间。
    uwsgi_send_timeout: 默认60秒，nginx向uwsgi进程发送请求的超时时间。
----------
How turn off request info in console:
    In Your Site-packages or VirtualEnv (if You're using it) directory,
    go to folder structure django / core / servers / basehttp.py
    then goto Class WSGIRequestHandler, function def log_message(self, format, *args)
e.g:
    if args[1][0] == '2':
        # Put 2XX first, since it should be the common case
        if 'notification' in msg:
            msg = ''
        msg = self.style.HTTP_SUCCESS(msg)
----------
DEBUG 为 False 的时候如何访问static和media:
.. code:: python
    if not settings.DEBUG:
        urlpatterns += [
            url(r'^media/(?P<path>.*)$', 'django.views.static.serve', {'document_root': settings.MEDIA_ROOT}),
            url(r'^static/(?P<path>.*)$', 'django.views.static.serve',{'document_root':settings.STATIC_ROOT}),
        ]
e.g: 这种情况可以看到url
[06/May/2019 10:00:46] "GET /media/alert_list/alert_None_None.xls HTTP/1.1" 200 5632

[06/May/2019 10:10:34] "GET /static/admin/css/dashboard.4898e2e9983d.css HTTP/1.1" 200 434
[06/May/2019 10:10:34] "GET /static/admin/css/base.9f6547179ace.css HTTP/1.1" 200 16062
    ...

自定义django.views.static.serve:
.. code:: python
    from django.views.static import serve

    def authorization_serve(request, path, document_root=None, show_indexes=False):
        if 'HTTP_AUTHORIZATION' in request.META:
            return serve(request, path, document_root, show_indexes)
        return

    if not settings.DEBUG:
        urlpatterns += [
            url(r'^media/(?P<path>.*)$', authorization_serve, {'document_root': settings.MEDIA_ROOT}),
            url(r'^static/(?P<path>.*)$', 'django.views.static.serve', {'document_root': settings.STATIC_ROOT}),
        ]
----------
Restframework Response class extends SimpleTemplateResponse, and all the usual attributes and methods are also available on the response. For example you can set headers on the response in the standard way:
    response = Response()
    response['Cache-Control'] = 'no-cache'
----------
.. code:: python
    class CaptchaView(views.APIView):
        '''图形验证码
        ---
        GET:
          type:
            hashkey:
              type: string
              description: 图形验证码hash key
            image_url:
              type: string
              description: 图形验证码图片地址
        '''
        authentication_classes = ()
        permission_classes = ()

        def get(self, request):
            hashkey = CaptchaStore.generate_key()
            image_url = captcha_image_url(hashkey)
            captcha = {'hashkey': hashkey, 'image_url': request.build_absolute_uri(image_url)}
            return Response({'data': captcha})

    >>> request.build_absolute_uri(image_url)  # 返回完整的uri
    >>> http://192.168.3.113:7799/captcha/image/3d81cb8c4e2799c606e58a5fc0331156962c318d/
----------
DJANGO SETTINGS USING HTTPS:
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
SECURE_SSL_REDIRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
----------
返回带https的media文件url: request.META['wsgi.url_scheme'] = 'https'
----------
nginx -c /etc/nginx/nginx.conf
    -c 配置文件，表示根据指定文件启动
    -t 可以查看是根据那个配置文件启动的
    -s signal: send signal to a master process: stop, quit, reopen, reload
----------
nginx https:
django:
    runserver:
        192.168.3.113:7799
    settings:
        SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')  # 返回地址http -> https, 例如:
            request: https://192.168.3.113:6443/auth/captcha/get/
            response: hashkey "a334c1d1307f96baf59f2b1c68cf915d7ffc631b"
                      image_url "https://192.168.3.113:6443/captcha/image/a334c1d1307f96baf59f2b1c68cf915d7ffc631b/"

nginx:
    events {
        worker_connections 1024;
    }
    http {
        server {
            listen 6443 ssl;
            ssl_certificate     /Users/zzz/b/Dfjk4NewEnergy/foobar.crt;
            ssl_certificate_key /Users/zzz/b/Dfjk4NewEnergy/foobar.key;
            location / {
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Host $http_host;
                # 不设置, image_url返回 192.168.3.113:7799, 设置, image_url返回 192.168.3.113:6443
                proxy_pass http://192.168.3.113:7799;
            }
        }
    }
The *proxy_redirect* off statement tells nginx that, if the backend returns an HTTP redirect, it should leave it as is.
----------
swagger use request_serializer and response_serializer:
.. code:: python
    def find_jambalaya(request):
        """
        Retrieve a *jambalaya* recipe by name or country of origin
        ---
        request_serializer: JambalayaQuerySerializer
        response_serializer: JambalayaSerializer
        """
        if request.method == 'POST':
            serializer = JambalayaQuerySerializer(data=request.DATA)
            if serializer.data['name'] is not None:
                j = Jambalaya.objects.filter(recipe__contains='name=%s' % serializer.data['name'])
            else:
                j = Jambalaya.objects.filter(recipe__contains="country=%s" % serializer.data['origin'])
            serializer = JambalayaSerializer(j, many=True)
            return Response(serializer.data)
        else:
            return Response("", status=status.HTTP_400_BAD_REQUEST)
----------