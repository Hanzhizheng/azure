vue computed vs methods:
    计算属性是基于它们的依赖进行缓存的, 多次访问计算属性会立即返回之前的计算结果，而不是再次执行函数；
    相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。
    我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于A 。如果没有缓存，我们将不可避免的多次执行A的getter！如果你不希望有缓存，请用方法来替代。
---
计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：

// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]  // js不支持names[-1]
    }
  }
}
// ...

https://www.cnblogs.com/tim100/p/7262963.html
当我们在使用v-for进行渲染时，尽可能使用渲染元素自身属性的id给渲染的元素绑定一个key值。

使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。
v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏。

props 可以传入传入多个数据
v-on 用于监听事件